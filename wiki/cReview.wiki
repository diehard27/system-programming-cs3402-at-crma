#summary ทบทวนภาษา C
<table width=500>
<td>
[CourseSchedule2555_2 กลับไปหน้าหลัก]-->[<a href="https://code.google.com/p/system-programming-cs3402-at-crma/wiki/CourseSchedule2555_2#ตารางเรียน_๒๕๕๕/๒">ตารางเรียน</a>]-->Next: [cSysProg C กับ System Programming]
<wiki:toc max_depth="3" />

==ทบทวนภาษา C==
 ภาษาซี เป็นภาษาที่พัฒนาขึ้นในปี ค.ศ. 1972 โดย [http://en.wikipedia.org/wiki/Dennis_Ritchie Dennis Ritchie] แห่ง Bell Labs เป็นภาษาที่พัฒนามาจากภาษา B และจากภาษา BCPL ช่วงแรกภาษาซีถูกออกแบบให้เป็นภาษาที่ใช้เขียนโปรแกรมในระบบปฏิบัติการ UNIX และต่อมาในปี ค.ศ. 1978 Ritchie ได้ร่วมกับ Brain Kernighan แต่งหนังสือชื่อว่า "The C Programming Language" ทำให้ภาษาซีเป็นที่นิยมแพร่หลายเป็นอย่างมาก จนกระทั่งในปี ค.ศ. 1988 Ritchie และ Kernighan ได้ร่วมกับ ANSI (American National Standards Institute) กำหนดมาตรฐานของภาษาซีขึ้นมา โดยใช้ชื่อว่า "ANSI C"

==การคอมไพล์ภาษาซีในระบบปฏิบัติการลินุกซ์==
อธิบายใน [compilingCprogram]


==ตัวอักษรพิเศษ==
ตัวอักษรพิเศษ (Escape sequence) เป็นค่าคงที่ตัวอักษรชนิดหนึ่งของภาษาซี ใช้ในการควบคุมการแสดงผลและการทำหน้าที่พิเศษอื่น ๆ การเขียนจะใช้ตัวอักษร "\" (escape character) นำหน้าแล้วตามด้วยตัวอักษรพิเศษที่กำหนด ส่วนใหญ่ตัวอักษรพิเศษ จะเป็นตัวอักษร 32 ตัวแรกของรหัส [http://en.wikipedia.org/wiki/ASCII ASCII] ตัวอักษรพิเศษที่นิยมใช้ในการเขียนโปรแกรมภาษาซี มีดังนี้

||ตัวอักษรพิเศษ||รหัสแอสกี||ความหมาย||
||\0 ||0 || NULL, ตัวปิดท้ายข้อความ (string) ||
||\a ||7 || alert, bell, กำหนดให้มีเสียงบี๊บ 1 ครั้ง||
||\b ||8 || backspace, เลื่อนเคอร์เซอร์ย้อนกลับไป 1 ช่อง||
||\t ||9 || horizontal Tab,เลื่อนเคอร์เซอร์ไปตามแนวนอน 1 แท็บ ||  
||\n ||10 || new line, เลื่อนเคอร์ลงไป 1 บรรทัด||
||\v ||11 || Vertical tab, เลื่อนเคอร์เซอร์ไปตามแนวตั้ง 1 แท็บ ||
||\f ||12 || form feed, เลื่อนเคอร์เซอร์ไปที่บรรทัดแรกของหน้าใหม่ || 
||\r ||13 || return, เลื่อนเคอร์เซอร์กลับไปต้นบรรทัด||
||\\ ||- || แสดงผลตัวอักษร \ (backslash) ||
||\' ||- || แสดงผลตัวอักษร ' (single quote)|| 
||\" ||- || แสดงผลตัวอักษร " (double quote)||
||\000 ||-  || กำหนดค่าตัวเลขฐานแปดจำนวน 1 ตัวอักษร ||
||\xhh ||-  ||กำหนดค่าตัวเลขฐานสิบหกจำนวน 1 ตัวอักษร ||

==ชนิดข้อมูลแบบ Enumeration==
 Enumeration หรือ enum เป็นชนิดข้อมูลที่มีสมาชิกเป็น "เซต" ซึ่งมีลักษณะคล้ายกับการประกาศค่าคงที่ที่เป็นตัวเลข โดยค่าที่คืนออกมาจะเป็นตัวเลขเท่านั้น เราสามารถสร้างสมาชิกและกำหนดค่าของสมาชิกแต่ละตัวได้
 * ในกรณีที่ไม่ได้มีการกำหนดค่า 
  # ค่าสมาชิกตัวแรกจะมีค่าเป็น 0
  # ค่าของสมาชิกตัวถัดไปคือ ค่าของสมาชิกตัวก่อนหน้า+1

 ตัวอย่างของการใช้ enum แสดงได้ดังโค้ดด้านล่าง
{{{
  1 //enum.c
  2 //by narong phoomsuk
  3 #include <stdio.h>
  4 int main(void){
  5         enum student{Wuttichai,Chaiyapat,Kulsiri=6,Athiwat} cadet1;
  6         enum student cadet2 = Chaiyapat;
  7         enum student cadet3 = Kulsiri;
  8         cadet1 = Wuttichai;
  9         printf("cadet1 is %d\n",cadet1); # => cadet1 is 0
 10         printf("cadet2 is %d\n",cadet2); # => cadet2 is 1
 11         printf("cadet3 is %d\n",cadet3); # => cadet3 is 6
 12         return 0;
 13 }
}}}

===แบบฝึกหัด=== 
ผลของการรันโปรแกรมนี้คืออะไร
{{{
  1 //enum.c
  2 //by narong phoomsuk
  3 #include <stdio.h>
  4 int main(void){
  5         enum student{Wuttichai,Chaiyapat,Kulsiri=6,Athiwat,Eakburut=1,Sanwut} cadet1,cadet2;
  6         enum student cadet3 = Athiwat;
  7         cadet1 = Eakburut;
  8         printf("cadet3 is %d\n",cadet3);
  9         cadet2 = Sanwut;
 10         printf("cadet1 is %d\n",cadet1);
 11         printf("cadet2 is %d\n",cadet2);
 12         cadet1 = Wuttichai;
 13         printf("cadet2 is %d\n",cadet1);
 14
 15         return 0;
 16 }
}}}

==ตัวแปรแบบตัวชี้==
ตัวแปรแบบตัวชี้ (Pointer) คือตัวแปรที่เก็บ *เลขตำแหน่ง (Address)* ที่อยู่ในหน่วยความจำของค่านั้น ๆ แตกต่างจากตัวแปรชนิดอื่นที่จะเก็บค่าต่าง ๆ ไว้ที่หน่วยความจำที่ได้มีการจองไว้ 

โดยทั่วไป เมื่อเราประกาศตัวแปร ภาษาซีจะทำการจองหน่วยความจำไว้เพื่อเก็บค่าต่าง ๆ ซึ่งขนาดของหน่วยความจำที่จองจะขึ้นอยู่กับชนิดข้อมูล (Data Type) เช่น
{{{
int a = 5;
}}}
จากโค้ดด้านบน ตัวแปร a มีชนิดข้อมูลเป็น integer ซึ่งต้องใช้พื้นที่หน่วยความจำขนาด 2 ไบต์ ภาษาซีก็จะเข้าไปทำการจองเนื้อที่บนหน่วยความจำ แล้วนำค่า 5 เข้าไปเก็บในหน่วยความจำที่ได้จองไว้ และทำฉลาก (Label) ตั้งชื่อหน่วยความจำส่วนนั้นว่า "a"

แต่ในตัวแปรที่เป็น pointer ภาษาซีจะทำการสร้างตัวแปรที่เก็บ *Address* ของหน่วยความจำขึ้นมา เพื่อใช้อ้างอิง(ชี้) ค่าที่อยู่ในหน่วยความจำนั้น เช่น
{{{
int a = 5;
int *pa = &a;
}}}
จากโค้ดด้านบน ตัวแปร pa ถูกประกาศให้เป็นตัวแปรแบบ pointer และเก็บ Address ของหน่วยความจำที่ตัวแปร a ได้ทำการจองไว้
 * เครื่องหมาย `*` ข้างหน้าตัวแปร pa บ่งบอกถึงการประกาศตัวแปร pa ให้เป็นตัวแปรชนิด pointer
 * เครื่องหมาย `&` ข้างหน้าตัวแปร a บ่งบอกถึง Address ของหน่วยความจำที่ตัวแปร a จองไว้
ตัวอย่างของการใช้ Pointer แสดงได้ดังโค้ดด้านล่าง
{{{
  1 //pointer.c
  2 // by narong phoomsuk
  3 #include <stdio.h>
  4
  5 int main(void){
  6
  7         int a=5;
  8         int *pa=&a;
  9
 10         printf("a=%d\n",a);   # a=5
 11         *pa=15;
 12         printf("a=%d\n",a);   # a=15
 13         return 0;
 14 }

}}}
จากโค้ดด้านบนที่บรรทัด 11 เราจะกำหนดให้ address ของหน่วยความจำที่ตัวแปร pointer pa ชี้อยู่มีค่าเป็น 15  ซึ่งก็คือ address ของตัวแปร a จึงทำให้บรรทัดที่ 13 เมื่อทำการแสดงค่า a จะได้ผลลัพธ์คือ a=15

==ฟังก์ชัน==
มีคำกล่าวไว้ว่า ภาษาซีเป็นภาษาฟังก์ชัน ซึ่งจะเห็นได้ว่าในการเขียนภาษาซีจะต้องประกาศฟังก์ชันอย่างน้อย 1 ฟังก์ชัน คือ main(){} และภาษาซีไม่มีโพรซีเจอร์ การเขียน sub routine จึงจำเป็นจะต้องใช้แต่ฟังก์ชันเท่านั้น ในกรณีที่ไม่ต้องการให้ sub routine ส่งค่า ต้องใช้ฟังก์ชันที่มีการส่งค่าเป็น void แทน
==ส่วนประกอบของฟังก์ชัน==
{{{
returnType functionName (argument1,argument2,...)   <--- Function Header
{
      statement;
      statement;
      statement;                                    <--- Function Body
      statement;
      ...
      statement;

}
}}}

===ส่วนหัวของฟังก์ชัน (Function Header)===
ส่วนหัวของฟังก์ชันจะเป็นตัวกำหนดรูปแบบการเรียกใช้ฟังก์ชัน และกำหนดค่าที่จะส่งกลับหลังจากการเรียกใช้ฟังก์ชัน

====รูปแบบ====
_returnType_ *_functionName_* (_argument_)

||returnType||กำหนดชนิดของข้อมูลที่จะให้ฟังก์ชันส่งค่ากลับ ถ้าไม่ต้องการให้ส่งค่ากลับ ให้กำหนดเป็น void||
||functionName|| ชื่อของฟังก์ชัน||
||argument||กำหนดค่าหรือข้อมูลที่ส่งผ่านเข้าไปทำงานในฟังก์ชัน ถ้าไม่ต้องการให้ส่งค่ากลับ ให้กำหนดเป็น void||

===ส่วนตัวฟังก์ชัน (Function Body)===
ส่วนตัวฟังก์ชัน เป็นส่วนหลักในการทำงานของฟังก์ชัน จะประกอบด้วยชุดคำสั่ง (statement) หรือนิพจน์ (expression) ต่าง ๆ ซึ่งจะอยู่ใน block ของเครื่องหมายวงเล็บปีกกา {}

==ต้นแบบฟังก์ชัน==
ต้นแบบฟังก์ชัน (Function Prototype) จะเป็นการกำหนด Function Header อีกแบบหนึ่ง เพื่อให้เรามีความสะดวกในการประกาศ function ไว้ส่วนใดก็ได้ เนื่องจากคอมไพเลอร์ภาษาซีจะทำงานไล่ทีละบรรทัดจากบน-ล่าง ตัวฟังก์ชันจึงจำเป็นต้องประกาศก่อนบรรทัดที่จะมีการเรียกใช้ฟังก์ชัน ไม่เช่นนั้นเมื่อมีการเรียกใช้ฟังก์ชันนั้น ๆ คอมไพเลอร์จะแจ้งว่า ไม่รู้จักฟังก์ชันที่เรียกใช้ การกำหนดต้นแบบฟังก์ชันให้อยู่ก่อนฟังก์ชัน main เพื่อให้คอมไพเลอร์ทราบว่ามีฟังก์ชันนี้อยู่ จะช่วยให้เราสามารถประกาศตัวฟังก์ชันไว้ที่ใดก็ได้ ไม่จำเป็นจะต้องประกาศตัวฟังก์ชันไว้ก่อนบรรทัดที่มีมีการเรียกใช้งานฟังก์ชันเสมอไป การประกาศต้นแบบฟังก์ชันจะเหมือนกันการประกาศส่วนหัวของฟังก์ชัน เพียงแต่เพิ่มเครื่องหมายเซมิโคลอน (;) ต่อท้ายเท่านั้น
====รูปแบบ====
_returnType_ *_functionName_* (_argument_);

อย่างไรก็ตาม ในภาษาซีเวอร์ชันใหม่ ๆ ได้พัฒนาความสามารถเพิ่มขึ้นโดยยอมให้ใช้ฟังก์ชันก่อนมีการประกาศได้ แต่จะมีการแสดงข้อความเตือนในขั้นตอนคอมไพล์ ([http://icecube.wisc.edu/~dglo/gcc-warnings.html implicit warning]) ว่าได้มีการเรียกใช้ฟังก์ชันก่อนมีการประกาศฟังก์ชันนั้น

ตัวอย่างการใช้งานฟังก์ชัน สามารถแสดงได้ตามโค้ดด้านล่าง

{{{
  1 //function.c
  2 // by narong phoomsuk
  3 #include <stdio.h>
  4 void sayHello(void);
  5 //void sayGoodbye(void);
  6
  7
  8 int main(void){
  9
 10         sayHello();
 11         sayGoodbye();
 12
 13         return 0;
 14 }
 15
 16 void sayHello(void){
 17
 18         printf("---------------------------\n");
 19         printf(" Hello\n");
 20         printf("---------------------------\n");
 21
 22 }
 23
 24 void sayGoodbye(void){
 25
 26         printf("---------------------------\n");
 27         printf(" Goodbye\n");
 28         printf("---------------------------\n");
 29 }

}}}
จากโค้ดตัวอย่างด้านบน จะพบว่าบรรทัดที่ 4 จะเป็นการประกาศต้นแบบฟังก์ชันของฟังก์ sayHello ส่วนบรรทัดที่ 5 จะ remark การประกาศต้นแบบฟังก์ชันของฟังก์ชัน sayGoodbye และตัวฟังก์ชันของทั้งสองฟังก์ชันนี้อยู่หลังฟังก์ชัน main เมื่อทำการคอมไพล์โปรแกรมจะพบว่าคอมไพเลอร์มีการแสดงข้อความเตือนเกี่ยวกับฟังก์ชัน sayGoodbye ดังนี้
{{{
function.c:24: warning: conflicting types for â€˜sayGoodbyeâ€™
function.c:11: note: previous implicit declaration of â€˜sayGoodbyeâ€™ was here
}}}
ซึ่งมีความหมายว่า คอมไพเลอร์ได้มีการพบว่ามีการเรียกใช้ฟังก์ชัน sayGoodbye ก่อนที่จะมีการประกาศฟังก์ชัน แต่ก็ยังยอมให้ทำงานต่อไปได้ 

จะสังเกตได้ว่า ทั้งฟังก์ชัน sayHello และฟังก์ชัน sayGoodbye ได้มีการประกาศตัวฟังก์ชันหลังฟังก์ชัน Main ทั้งคู่ แต่คอมไพเลอร์มีการเตือนเฉพาะฟังก์ชัน sayGoodbye แต่ไม่เตือนฟังก์ชัน sayHello ทั้งนี้เนื่องจากเราได้มีการประกาศต้นแบบฟังก์ชัน sayHello ไว้แล้วนั่่นเอง

การแก้ไขข้อความเตือนของฟังก์ชัน sayGoodbye ทำได้โดยการประกาศตัวแบบฟังก์ชัน sayGoodbye  หรือเขียนตัวฟังก์ชัน sayGoodbye ไว้ก่อนที่จะมีการประกาศใช้

==การส่งผ่านค่าให้กับฟังก์ชัน==
การส่งผ่านค่าคือการนำค่าจากภายนอกไปใช้ประมวลผลในฟังก์ชัน โดยทำการส่งค่าจาก argument หรือตัวแปรที่อยู่ในวงเล็บหลังชื่อฟังก์ชัน การส่งผ่านค่าให้ฟังก์ชันในภาษาซีมี 2 แบบได้แก่ การส่งค่าแบบ pass by value และ pass by reference

===Pass by Value===
คือการส่งค่าหรือคัดลอกค่าที่อยู่ในตัวแปรเข้ามาในฟังก์ชัน ถ้ามีการเปลี่ยนแปลงค่าตัวแปรในฟังก์ชัน ตัวแปรที่เป็น argument จะไม่เกิดการเปลี่ยนแปลงใด ๆ ตัวอย่างการส่งค่าแบบ pass by value แสดงได้ดังโค้ดข้างล่าง
{{{
  1 //passbyvalue.c
  2 // by narong phoomsuk
  3 #include <stdio.h>
  4 int sumof(int startvalue, int stopvalue){
  5         int i;
  6         int sumof = 0;
  7         for(i=startvalue;i<=stopvalue;i++)
  8                 sumof+=i;
  9         startvalue=5;
 10         stopvalue=5;
 11         return sumof;
 12 }
 13
 14 int main(void){
 15         int a=1,b=4;
 16         printf("a=%d,b=%d\n",a,b);       # a=1,b=4
 17         int sum = sumof(a,b);
 18         printf("sum=%d\n",sum);           # sum=10
 19         printf("a=%d,b=%d\n",a,b);       # a=1,b=4
 20         return 0;
 21 }

}}}

จากโค้ดด้านบนบรรทัดที่ 4-12 จะเป็นการประกาศตัวฟังก์ชันชื่อ sumof ซึ่งให้ผลในการบวกเลขตั้งแต่ 1 ถึงจำนวนที่กำหนด และในบรรทัดที่ 9 และ 10 มีการเปลี่ยนแปลงค่าของตัวแปรที่เป็น parameter ทั้งสองตัว (ข้อสังเกตจะเห็นได้ว่า sumof ไม่ได้ประกาศต้นแบบฟังก์ชัน แต่ตอนคอมไพล์ก็ไม่มีข้อความแจ้งเตือนใด ๆ ทั้งนี้เนื่องจากเราได้ทำการประกาศตัวฟังก์ชันก่อนบรรทัดที่เรียกใช้งานคือบรรทัดที่ 17) ต่อมาในบรรทัดที่ 14-21 จะเป็นส่วนของฟังก์ชัน main  โดยบรรทัดที่ 16 จะเป็นการแสดงค่าของตัวแปร a และ b ก่อนทำฟังก์ชัน sumof และบรรทัดที่ 19 จะเป็นการแสดงค่าของตัวแปร a และ b หลังจากทำฟังก์ชัน sumof จะเห็นค่า a และ b ก่อนและหลังทำฟังก์ชัน จะไม่เปลี่ยนแปลง ทั้งนี้เนื่องจากการส่งค่าให้ฟังก์ชันเป็นแบบ pass by value นั่นเอง

===Pass by Reference===
คือการส่งค่าแบบอ้างอิง กล่าวคือการส่ง address ของหน่วยความจำที่ตัวแปรนั้นเก็บค่าอยู่ เข้ามาในฟังก์ชัน ถ้ามีการเปลี่ยนแปลงค่าตัวแปรในฟังก์ชัน ตัวแปรที่เป็น argument จะเกิดการเปลี่ยนแปลงค่าด้วย การส่งค่าแบบ Pass by Reference นี้มักใช้เป็นเทคนิคในการเขียนโปรแกรม กรณีที่ต้องการให้ฟังก์ชันสามารถ return ค่าได้มากกว่า 1 ค่าในภาษาซี  ตัวอย่างการส่งค่าแบบ pass by value แสดงได้ดังโค้ดข้างล่าง
{{{
  1 //passbyref.c
  2 // by narong phoomsuk
  3 #include <stdio.h>
  4 int sumof(int startvalue, int* stopvalue){
  5         int i;
  6         int sumof = 0;
  7         for(i=startvalue;i<=*stopvalue;i++)
  8                 sumof+=i;
  9         startvalue=5;
 10         *stopvalue=5;
 11         return sumof;
 12 }
 13
 14 int main(void){
 15         int a=1,b=4;
 16         printf("a=%d,b=%d\n",a,b);  #a=1,b=4
 17         int sum = sumof(a,&b);
 18         printf("sum=%d\n",sum);      # sum = 10
 19         printf("a=%d,b=%d\n",a,b);  # a=1,b=5
 20         return 0;
 21 }
}}}
จากโค้ดด้านบนจะเห็นว่า โค้ดแทบจะเหมือนกับโค้ดในส่วนของ passbyvalue.c เกือบทุกประการ แตกต่างกันเล็กน้อยในส่วนของฟังก์ชัน sumof ที่บรรทัดที่ 4 ตัวแปร parameter stopvalue ถูกกำหนดให้เป็น pointer เพื่อให้สามารถส่งค่าแบบ pass by reference ได้ ที่บรรทัดที่ 7 และ 10 จะเห็นว่าการเรียกใช้ stopvalue ทุกครั้งจะต้องมีเครื่องหมาย `*` นำหน้าเสมอ บรรทัดที่ 7 หมายถึงการเรียกใช้ค่าในหน่วยความจำ ที่ ตัวแปร pointer stopvalue ชี้อยู่ ในส่วนของบรรทัดที่ 10 หมายถึง การนำค่า 10 ไปใส่ในหน่วยความจำ ที่ัตัวแปร pointer stopvalue ชี้อยู่ ส่วนโค้ดของฟังก์ชัน main ต่างกันเล็กน้อยที่บรรทัดที่ 17 การส่งค่า argument ของตัวแปร b จะมีเครื่องหมาย & อยู่ข้างหน้า ซึ่งหมายถึง การ ส่ง address ของหน่วยความจำที่ตัวแปร b ใช้เก็บค่าให้กับฟังก์ชัน sumof ผลจากกันโปรแกรม จะพบว่าค่าของตัวแปร b มีการเปลี่ยนแปลงหลังจากการทำงานของฟังก์ชัน sumof ซึ่งเป็นผลจากการส่งค่าให้ฟังก์ชันแบบ pass by reference นั่นเอง

==ชนิดข้อมูลแบบ struct==

==การส่งค่า Argument ให้โปรแกรม==
นอกจากที่เราจะสามารถส่งค่า argument ให้ฟังก์ชันได้แล้ว เรายังสามารถส่งค่า argument ให้กับตัวโปรแกรมภาษาซีได้อีกด้วย โดยการกำหนด argument มาตรฐานให้กับฟังก์ชัน main ของโปรแกรมดังนี้
{{{
int main (int argc, char *argv[])
}}}
จากโค้ดจะพบว่ามี argument 2 ตัว ตัวแรกเป็นชนิด integer ส่วนอีกตัวเป็น array ของ pointer ชนิด character
 * argc     argument count เป็นตัวแปรที่เก็บจำนวนของ argument ที่รับเข้ามาในโปรแกรม ซึ่งรวมไปถึงชื่อของโปรแกรมด้วย
 * argv     argument vector เป็น list ของ argument ที่รับมา โดยที่ `argv[0]` จะเป็นชื่อของโปรแกรม

ตัวอย่างการส่งค่า argument ให้โปรแกรมแสดงได้จากโค้ดด้านล่าง
{{{
  1 //octhex.c
  2 // by narong phoomsuk
  3 // usage : octhex.c o 10
  4 //         octhex.c h 99
  5 #include <stdio.h>
  6
  7 int main(int argc, char* argv[]){
  8         if(argc != 3){ //argc should be 3 for correct execution
  9                 printf("usage : %s o 10\n",argv[0]);
 10                 printf("usage : %s h 99\n",argv[0]);
 11                 return -1;
 12         }
 13         char choice = *argv[1];
 14         int num = atoi(argv[2]);
 15         switch(choice){
 16                 case 'o' : printf("The value of %s in OCTAL is %o\n",argv[2],num);
 17                            break;
 18                 case 'h' : printf("The value of %s in HEXADECIMAL is %X\n",argv[2],num);
 19                            break;
 20                 default : printf("invalid argument\n");
 21         }
 22
 23         return 0;
 24 }

}}}
จากตัวอย่างด้านบนจะเป็นการสร้างโปรแกรม octhex ซึ่งใช้แปลงค่าเลขฐานสิบ เป็นฐานแปดหรือฐานสิบหก โดยบรรทัดที่ 8 โปรแกรมจะตรวจสอบว่า จำนวน argument ที่ร้บมา เท่ากับ 3 หรือไม่ (ชื่อโปรแกรม + argument ที่เป็น input) ถ้าไม่ใช่ก็จะแสดงวิธีใช้และออกจากโปรแกรม ด้วยคำสั่ง return ในบรรทัดที่ 11 ถ้ามี จากนั้นในบรรทัดที่ 13 จะประกาศตัวแปร choice ซึ่งเป็นชนิด character รับค่าที่อยู่ใน address ที่ argv`[1]` ชี้อยู่ บรรทัดที่ 14 จะใช้ฟังก์ชัน atoi ซึ่งเป็นฟังก์ชันมาตรฐานที่้ใช้ในการแปลง string หรือ character ให้เป็นตัวเลข จะสังเกตได้ว่า ที่บรรทัดนี้ `argv[2]` จะไม่มีเครื่องหมาย `*` นำหน้า เนื่องจากฟังก์ชัน atoi รับ argument เป็น string ได้ และ `argv[2]` เป็น array of character ซึ่งก็คือ string เช่นกัน จึงไม่ต้องมีเครื่องหมาย `*` นำหน้า (ถ้าใส่จะคอมไพล์ผ่าน แต่ตอนรันจะเกิด [http://en.wikipedia.org/wiki/Segmentation_fault Segmentation Fault]) บรรทัดที่ 15-20 เป็นการเปรียบเทียบค่า choice ด้วย switch บรรทัดที่ 16 ในกรณีที่ choice เป็น 'o' จะทำการแปลงเลขฐานสิบให้เป็นเลขฐานแปดด้วย format "%o" ของฟังก์ชัน printf ส่วนบรรทัดที่ 18 ในกรณ๊ที่ choice เป็น 'h' จะทำการแปลงเลขฐานสิบให้เป็นเลขฐานสิบหกด้วย format "%X" ของฟังก์ชัน printf



=References=
  # Robert Love, _LINUX System Programming_ , O'Rielly, 2007.[http://mirror.paramadina.ac.id/pub/linux/doc/book/Linux.System.Programming.pdf  PDF]
----
[CourseSchedule2555_2 กลับไปหน้าหลัก]-->[<a href="https://code.google.com/p/system-programming-cs3402-at-crma/wiki/CourseSchedule2555_2#ตารางเรียน_๒๕๕๕/๒">ตารางเรียน</a>]-->Next: [cSysProg C กับ System Programming]

[https://code.google.com/p/system-programming-cs3402-at-crma/w/edit/cReview Edit]