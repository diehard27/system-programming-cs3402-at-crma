#summary ภาษา C กับ System Programming
<table width=500>
<td>
[CourseSchedule2555_2 กลับไปหน้าหลัก]-->[<a href="https://code.google.com/p/system-programming-cs3402-at-crma/wiki/CourseSchedule2555_2#ตารางเรียน_๒๕๕๕/๒">ตารางเรียน</a>]-->Next: [cSysProg C กับ System Programming]
<wiki:toc max_depth="3" />

==inode==
inode, index node (ดัชนีโหนด)เป็นเลขรหัสของไฟล์ที่มีในระบบไฟล์ของระบบปฏิบัติการ Unix หรือ Linux ระบบปฏิบัติการจะมองทรัพยากรหรือวัตถุทุกอย่างเป็นไฟล์ และใช้เลข inode ในการอ้างอิงไฟล์ โดย inode จะเก็บข้อมูลต่าง ๆ เกี่ยวกับไฟล์ หรือที่เรียกว่า meta-data เช่น ชนิดของไฟล์, ชื่อเจ้าของ, ชื่อกลุ่ม, ขนาดไฟล์, สิทธิ์ในใช้ไฟล์, เวลาในการอ่านและเขียนไฟล์ (UNIX  และ Linux จะไม่เก็บเวลาในการสร้างไฟล์), เวลาในการลบไฟล์ เป็นต้น

 * เลข inode จะไม่ซ้ำกัน

===คำสั่งที่ใช้ดูเลข inode===

{{{
$ ls -i /etc/passwd
}}}

===การประยุกต์ใช้ inode===

{{{
$ cd /tmp
$ ls -l
}}}

จะได้ผลลัพธ์ดังนี้
{{{
prachya@pcubusrv104> ls -l
total 8
-rw-r--r-- 1 prachya prachya 2082 2012-11-14 16:51 gchart-disk.pl
-rw-r--r-- 1 prachya prachya    6 2012-11-05 13:34 junk
}}}
ในที่นี้ ls จะแสดงรายละเอียดของไฟล์แต่ไม่แสดง inode โดยที่ total 8 ในที่นี้หมายถึงจำนวน blocks ที่ถูกใช้ในไดเร็กทอรี่/ไฟล์นี้ (สามารถตรวจสอบดูได้ด้วยคำสั่ง ls -s ซึ่งจะแสดงจำนวน blocks ที่ใช้ในแต่ละไฟล์/ไดเร็กทอรี่

ในกรณีที่เราต้องการดูรายละเอียดของ index ของ inode สามารถใช้ตัวเลือก -i เพื่อให้แสดงข้อมูลของ inode ได้
{{{
$ ls -il /tmp
}}}
จะได้ผลลัพธ์ดังนี้
{{{
prachya@pcubusrv104> ls -il /tmp
total 8
2496286 -rw-r--r-- 1 prachya prachya 2082 2012-11-14 16:51 gchart-disk.pl
2101314 -rw-r--r-- 1 prachya prachya    6 2012-11-05 13:34 junk
}}}

===stat แสดง inode===
โปรแกรม stat จะแสดงรายละเอียดต่าง ๆ ของไฟล์/ไดเร็กทอรี่ รวมถึงข้อมูลของ inode ดังตัวอย่าง

{{{
prachya@pcubusrv104> stat /tmp/junk
  File: `/tmp/junk'
  Size: 6               Blocks: 8          IO Block: 4096   regular file
Device: 803h/2051d      Inode: 2101314     Links: 1
Access: (0644/-rw-r--r--)  Uid: ( 1001/ prachya)   Gid: ( 1001/ prachya)
Access: 2012-11-05 13:34:21.479437961 +0700
Modify: 2012-11-05 13:34:03.455437909 +0700
Change: 2012-11-05 13:34:03.455437909 +0700
}}}

===C โปรแกรมที่เข้าถึง inode===

ตัวอย่างโปรแกรมภาษา C ต่อไปนี้ใช้ไลบรารี่ fstat() เพื่อเรียกดูข้อมูลของไฟล์/ไดเร็กทอรี่
รูปแบบของ fstat()
{{{
int fstat(int fildes, struct stat *buf);
}}}
โดยที่

||Field||Description||
||int fildes||	The file descriptor of the file that is being inquired.||
||{{{struct stat *buf}}} ||	A structure where data about the file will be stored. A detailed look at all of the fields in this structure can be found in the struct stat page. ||
||return value||	Returns a negative value on failure.||

ดูรายละเอียดของ sys/stat.h ได้ด้วยคำสั่ง
{{{
man -s 2 stat
}}}

{{{
// test-fstat.c
#include <unistd.h>
#include <fcntl.h>
#include <stdio.h>
#include <sys/stat.h>
#include <sys/types.h>
 
int main(int argc, char **argv)
{
    if(argc != 2)    
        return 1;
 
    int file=0;
        if((file=open(argv[1],O_RDONLY)) < -1)
            return 1;
 
    struct stat fileStat;
    if(fstat(file,&fileStat) < 0)    
        return 1;
 
    printf("Information for %s\n",argv[1]);
    printf("---------------------------\n");
    printf("File Size: \t\t%d bytes\n",fileStat.st_size);
    printf("Number of Links: \t%d\n",fileStat.st_nlink);
    printf("File inode: \t\t%d\n",fileStat.st_ino);
 
    printf("File Permissions: \t");
    printf( (S_ISDIR(fileStat.st_mode)) ? "d" : "-");
    printf( (fileStat.st_mode & S_IRUSR) ? "r" : "-");
    printf( (fileStat.st_mode & S_IWUSR) ? "w" : "-");
    printf( (fileStat.st_mode & S_IXUSR) ? "x" : "-");
    printf( (fileStat.st_mode & S_IRGRP) ? "r" : "-");
    printf( (fileStat.st_mode & S_IWGRP) ? "w" : "-");
    printf( (fileStat.st_mode & S_IXGRP) ? "x" : "-");
    printf( (fileStat.st_mode & S_IROTH) ? "r" : "-");
    printf( (fileStat.st_mode & S_IWOTH) ? "w" : "-");
    printf( (fileStat.st_mode & S_IXOTH) ? "x" : "-");
    printf("\n\n");
 
    printf("The file %s a symbolic link\n\n", (S_ISLNK(fileStat.st_mode)) ? "is" : "is not");
 
    return 0;
}
// source: http://codewiki.wikidot.com/c:system-calls:fstat
}}}

คอมไพล์โปรแกรมด้วยคำสั่ง 
{{{
gcc test-fstat.c -o test-fstat
}}}
ทดสอบการทำงาน
{{{
prachya@pcubusrv104> ./test-fstat /tmp/junk
Information for /tmp/junk
---------------------------
File Size:              6 bytes
Number of Links:        1
File inode:             2101314
File Permissions:       -rw-r--r--

The file is not a symbolic link
}}}

==FILE I/O==
การเขียนโปรแกรมติดต่อไฟล์บนระบบปฏิบัติการ Linux นั้นจำเป็นจะต้องมีการเปิดไฟล์ก่อน ซึ่งตัว kernel ได้สร้าง List ของไฟล์ที่เปิดอยู่ไว้ให้ เรียกว่า File Table ซึ่งใน File Table จะมีเลขดัชนีที่ไม่มีค่าติดลบ เรียกว่า File Descriptor (fds) ซึ่งจะมีรายละเอียดต่าง ๆ เกี่ยวกับการเปิดไฟล์ รวมถึงรายละเอียดเกี่ยวกับหน่วยความจำที่ใช้ในการเปิดไฟล์ด้วย

==system call function==
เป็นฟังก์ชันระดับ Low-Level ของระบบปฏิบัติการ ซึ่งมีความรวดเร็วสูงในการทำงาน แต่มีข้อจำกัดคือฟังก์ชันจะผูกกับระบบปฏิบัติการนั้น ๆ และการใช้งานค่อนข้างยุ่งยาก 

(หมายเหตุ: standard C library จะมีการติดต่อกับไฟล์ด้วย fopen(), fclose() ฟังก์ชันซึ่ง
สามารถดูรายละเอียดของการใช้งานด้วยคำสั่ง {{{man fopen}}} ซึ่งเป็นมาตรฐานของภาษา C ดังนั้นหากต้องการให้โปรแกรม portable โปรแกรมเมอร์ควรพิจารณาใช้งาน fopen() มากกว่า )

==open( ) System Call ==
เป็น system call ที่ใช้สำหรับเปิดไฟล์ (ดูรายละเอียดใน man page ด้วยคำสั่ง {{{man -s 2 open}}}

{{{
#include <sys/types.h> 
#include <sys/stat.h> 
#include <fcntl.h> 
int open (const char *name, int flags); 
int open (const char *name, int flags, mode_t mode);
}}}

ตัวอย่างการใช้ open() System Call
{{{
int fd; 
fd = open ("/home/kidd/madagascar", O_RDONLY); 
if (fd == -1) 
/* error */ 
}}}

==Flag ของ open() System Call ที่น่าสนใจ==
 * O_APPEND
The file will be opened in append mode. That is, before each write, the file 
position will be updated to point to the end of the file. This occurs even if another 
process has written to the file after the issuing process' last write, thereby 
changing the file position. (See "Section 2.3.2" later in this chapter). 
 * O_ASYNC
A signal (SIGIOby default) will be generated when the specified file becomes 
readable or writable. This flag is available only for terminals and sockets, not for 
regular files. 
 * O_CREAT
If the file denoted by name does not exist, the kernel will create it. If the file 
already exists, this flag has no effect unless O_EXCL is also given. 
Linux System Programming 
38 of 396 
 * O_DIRECT
The file will be opened for direct I/O (see "Section 2.5" later in this chapter). 
 * O_DIRECTORY
If nameis not a directory, the call to open( )will fail. This flag is used internally 
by the opendir( )library call. 
 * O_EXCL
When given with O_CREAT, this flag will cause the call to open( ) to fail if the file 
given by name already exists. This is used to prevent race conditions on file 
creation. 
 * O_LARGEFILE
The given file will be opened using 64-bit offsets,allowing files larger than two 
gigabytes to be opened. This is implied on 64-bit architectures. 
 * O_NOCTTY
If the given name refers to a terminal device (say, /dev/tty), it will not become 
the process' controlling terminal, even if the process does not currently have a 
controlling terminal. This flag is not frequently used. 
 * O_NOFOLLOW
If name is a symbolic link, the call to open( ) will fail. Normally, the link is 
resolved, and the target file is opened. If other components in the given path are 
links, the call will still succeed. For example, if name is /etc/ship/plank.txt, the 
call will fail if plank.txt is a symbolic link. It will succeed, however, if etcor ship
is a symbolic link, so long as plank.txt is not. 
 * O_NONBLOCK 
If possible, the file will be opened in non blocking mode. Neither the open( ) call, 
nor any other operation will cause the process to block (sleep) on the I/O. This 
behavior may be defined only for FIFOs. 
 * O_SYNC
The file will be opened for synchronous I/O. No write operation will complete until 
the data has been physically written to disk; normal read operations are already 
synchronous, so this flag has no effect on reads. POSIX additionally defines 
O_DSYNC and O_RSYNC; on Linux, these flags are synonymous with O_SYNC.    

 * O_TRUNC
If the file exists, it is a regular file, and the given flags allow for writing, the file 
will be truncated to zero length. Use of O_TRUNCon a FIFO or terminal device is 
ignored. Use on other file types is undefined. Specifying O_TRUNC with O_RDONLY
is also undefined, as you need write access to the file in order to truncate it. 
For example, the following code opens for writing the file /home/teach/pearl. If the file 
already exists, it will be truncated to a length of zero. Because the O_CREAT flag is not 
specified, if the file does not exist, the call will fail: 
{{{
int fd; 
fd = open ("/home/teach/pearl", O_WRONLY | O_TRUNC); 
if (fd == -1) 
/* error */ 
}}}
==close( ) System Call ==
เป็น system call ที่ใช้สำหรับปิดไฟล์
รูปแบบของ close()
{{{
#include <unistd.h> 
int close (int fd);
}}}
ตัวอย่างการใช้งานของ close() System Call
{{{
if (close (fd) == -1) 
perror ("close"); 
}}}

==ตัวอย่าง xcpy.c==

{{{
// xcpy.c
#include <stdio.h>
#include <stdarg.h>
#include <fcntl.h>
//#include <syscalls.h>
#define PERMS 0666     /* RW for owner, group, others */

  /* error:  print an error message and die */
void error(char *fmt, ...)
{
       va_list args;

       va_start(args, fmt);
       fprintf(stderr, "error: ");
       fprintf(stderr, fmt, args);
       fprintf(stderr, "\n");
       va_end(args);
       exit(1);
}

   /* cp:  copy f1 to f2 */
main(int argc, char *argv[])
{
       int f1, f2, n;
       char buf[BUFSIZ];

       if (argc != 3)
           error("Usage: cp from to");
       if ((f1 = open(argv[1], O_RDONLY, 0)) == -1)
           error("cp: can't open %s", argv[1]);
       if ((f2 = creat(argv[2], PERMS)) == -1)
           error("cp: can't create %s, mode %03o",
               argv[2], PERMS);
       while ((n = read(f1, buf, BUFSIZ)) > 0)
           if (write(f2, buf, n) != n)
               error("cp: write error on file %s", argv[2]);
       return 0;
}

// modified from source: http://www.java-samples.com/showtutorial.php?tutorialid=570
}}}

==Process==
 ความหมายของ Process ที่ถูกใช้บ่อย ๆ คือ "โปรแกรมที่กำลังประมวลผลอยู่" โดยคำว่า process จะมีความหมายเช่นเดียวกับ job หรือ task โดยในแต่ละ Process จะมีรายละเอียดต่าง ๆ ดังนี้
 * ทุก ๆ Process จะมี "process ID" ซึ่งเป็นเลขไม่ซ้ำกัน (Unique)
 * process ID จะมีค่าเป็นเลขจำนวนเต็มบวกเสมอ
 * ถึงแม้ processID จะไม่ซ้ำกัน, แต่เลข process ID จะถูกนำกลับมาใช้ใหม่ได้
 * แต่ละ processID จะมีสถานะในการประมวลผล (state)
ในระบบที่มีตัวประมวลผลเดียว ก็ยังสามารถรันหลาย ๆ process ได้ในเวลาเดียวกัน เช่นเดียวกับระบบที่มีตัวประมวลผลหลายตัว การเรียกโปรแกรมให้ทำงานเป็นการเริ่มต้นการสร้าง process เมื่อโปรแกรมถูกรัน process จะถูกสร้างขึ้นและมีการจ่าย processID ให้กับ process นั้น โดยฟังก์ชัน getpid() จะสามารถแสดง processID ของ process ที่กำลังรันอยู่ได้

==ฟังก์ชัน getpid()==
เป็นฟังก์ชันที่อยู่ใน library <unistd.h> ใช้ในแสดงเลข processID ของโปรแกรมที่กำลังทำงานอยู่

ตัวอย่างการทำงานของ getpid() แสดงดังโค้ดด้านล่าง

{{{
  1 //getpid.c
  2 #include <stdio.h>
  3 #include <unistd.h>
  4 int main(void){
  5         printf("Hello, this is process ID %d\n",getpid());
  6         return 0;
  7 }

}}}

ในเครื่องที่มีตัวประมวลผลเดี่ยว แต่ละ Process จะถูกเรียกเข้ามาประมวลผล ในช่วงเวลาอันสั้น เราสามารถใช้คำสั่ง ps สำหรับแสดง processID ทั้งหมดที่กำลังทำงานอยู่ได้ โดยคำสั่ง ps จะแสดง ProcessID, ชื่อของ terminal(TTY), เวลาที่ Process ใช้ในการประมวลผล (TIME), และคำสั่งที่กำลังประมวลผลอยู่ (CMD)

{{{
$ ps
  PID TTY          TIME CMD
 6506 pts/2    00:00:00 bash
 6573 pts/2    00:00:00 ps

}}}
 อย่างไรก็ตาม คำสั่ง ps จะแสดงเฉพาะ Process ของผู้ใช้ที่กำลังประมวลผลอยู่ ณ ปัจจุบัน แต่เราสามารถใช้ flag เพื่อให้แสดง process ทั้งหมดได้ด้วย flag "-a", และยังสามารถแสดงข้อมูล process ในแบบเต็มรูปได้ด้วย flag "-l"

ข้อมูลเพิ่มเติมของแต่ละ process ได้แก่
||PID|| เลข processID ที่เป็นเลขจำนวนเต็มบวก||
||PPID|| เลข processID แม่ (Parent Process) ที่เป็นเลขจำนวนเต็มบวก||
||STAT|| สถานะของ Process||
||TIME|| CPU Time ที่ process ใช้ (เป็นวินาที)||
||PID|| เลข processID ที่เป็นเลขจำนวนเต็มบวก||
||PID|| เลข processID ที่เป็นเลขจำนวนเต็มบวก||
||PID|| เลข processID ที่เป็นเลขจำนวนเต็มบวก||

==Error Handling==
การเกิดข้อผิดพลาด (Error) เป็นสิ่งที่อยู่คู่กับการเขียนโปรแกรม ภาษาซีได้เตรียม `errno` สำหรับการรับมือกับข้อผิดพลาด ทั้งในส่วนการใช้ library และ system call ซึ่งโดยปกติแล้ว หากฟังก์ชันมีการทำงานผิดพลาดจะส่งคืนค่า -1 กลับมาเป็นค่าปริยาย (ค่าที่ return มาจริงขึ้นอยู่กับแต่ละฟังก์ชันว่าจะกำหนดให้เป็นอย่างอื่นหรือเปล่า) ด้วยค่าที่ส่งกลับนี้จะบ่งบอกเพียงว่า มีข้อผิดพลาดในการทำงานเกิดขึ้น แต่ไม่ได้บอกว่า เกิดข้อผิดพลาดจากสาเหตุใด ตัวแปร `errno` จึงเป็นเครื่องมือสำคัญที่ใช้ในการสาเหตุของข้อผิดที่เกิดขึ้น

ตัวแปร errno ถูกประกาศไว้ใน library <errno.h> ดังนี้
{{{
extern int errno;
}}}

ค่าของตัวแปร errno ได้ถูก map กับคำอธิบายข้อผิดพลาดต่าง ๆ และ Preprocessor `#define` ก็ได้ทำการ map ค่า errno ที่เป็นตัวเลข ให้เป็นค่าคงที่ เช่น ถ้า preprocessor ระบุค่า EACCESS ให้เท่ากับ 1 นั่นหมายความว่า เกิดข้อผิดพลาด `Permission denied` ตารางด้านล่างจะแสดงรายละเอียด ของ คำอธิบายข้อผิดพลาดต่าง ๆ ที่ระบุไว้ใน Preprocesser

||*Preprocessor define* ||  *Description* ||
||E2BIG || Argument list too long ||
||EACCESS |||| Permission denied ||
||EAGAIN || Try again ||
||EBADF || Bad file number ||
||EBUSY || Device or resource busy ||
||ECHILD || No child processes ||
||EDOM || Math argument outside of domain of function ||
||EEXIT || File already exists ||
||EFAULT || Bad address ||
||EFBIG || File too large ||
||EINTR || System call was interrupted ||
||EINVAL || Invalid argument ||
||EIO || I/O  error ||
||EISDIR || Is a directory ||
||EMFILE || Too many open files ||
||EMLINK || Too many links ||
||ENFILE || File table overflow ||
||ENODEV || No such device ||
||ENOENT || No such file or directory ||
||ENOEXEC || Exec format error ||
||ENOMEM || Out of memory ||
||ENOSPC || No space left on device ||
||ENOTDIR || Not a directory ||
||ENOTTY || Inappropriate I/O control operation ||
||ENXIO || No such device or address ||
||EPERM || Operation not permitted ||
||EPIPE || Broken pipe ||
||ERANGE || Result too large ||
||EROFS || Read-only filesystem ||
||ESPIPE || Invalid seek ||
||ESRCH || No such process ||
||ETXTBSY || Text file busy ||
||EXDEV || Improper link ||

===ฟังก์ชันสำหรับรายงานข้อผิดพลาด===
ภาษาซี ได้จัดเตรียมฟังก์ชันสำหรับแปลค่า errno ให้อยู่ในรูปแบบของข้อความแจ้งข้อผิดพลาด ฟังก์ชันที่ใช้ในการรายงานข้อผิดพลาดมีดังนี้

=== perror()===
ฟังก์ชันนี้จะทำการ พิมพ์ข้อความแจ้งข้อผิดพลาดไปยัง stderr รูปแบบการประกาศฟังก์ชัน ดังโค้ดด้านล่าง
{{{
#include <stdio.h> 
 void perror (const char *str);
}}}
===ตัวอย่างการใช้งาน perror===
{{{
  1 // checkfile.c
  2 // by narong phoomsuk
  3 // usage : ./checkfile filename
  4 #include <stdio.h>        // for printf()
  5 #include <sys/types.h> // for open()
  6 #include <sys/stat.h>   // for open()
  7 #include <fcntl.h>        // for open()
  8 #include <errno.h>      // for errno
  9 #include <stdlib.h>      // for exit()
 10 #include <unistd.h>    // for close()
 11
 12 int main(int argc,char* argv[]){
 13         int fd;
 14         if(argc!=2){
 15                 printf("usage : %s filename\n",argv[0]);
 16                 perror("Invalid argument\n");
 17                 exit(-1);
 18         }
 19         fd = open (argv[1],O_RDONLY);
 20         if (fd==-1){
 21                 perror("open file failed\n");
 22                 printf("Cannot open %s\n",argv[1]);
 23                 exit(-1);
 24         }
 25         if (close(fd)==-1){
 26                 perror("close file failed\n");
 27                 printf("Cannot open %s\n",argv[1]);
 28                 exit(-1);
 29         }
 30         return 0;
 31 }
}}}
จากโค้ดด้านบน บรรทัดที่ 16, 21, และ 26 หากเกิดข้อผิดพลาดฟังก์ชัน perror จะแสดงข้อความในวงเล็บ แต่ต่อท้ายด้วย เครื่องหมาย ":" และสาเหตุที่เกิดข้อผิดพลาด

===ตัวอย่างการรันโปรแกรม checkfile===
{{{
 $ ./checkfile file1.txt
open file failed
: No such file or directory
Cannot open file1.txt
 $  ./checkfile file1.txt 2>err2.txt
Cannot open file1.txt
}}}
=References=
  # Robert Love, Linux System Programming, O'Rielly, 2007. [http://seesee.pbworks.com/f/linux.pdf  [PDF]]
----
[CourseSchedule2555_2 กลับไปหน้าหลัก]-->[<a href="https://code.google.com/p/system-programming-cs3402-at-crma/wiki/CourseSchedule2555_2#ตารางเรียน_๒๕๕๕/๒">ตารางเรียน</a>]-->Next: [CShell C กับ การติดต่อกับ Shell]

[https://code.google.com/p/system-programming-cs3402-at-crma/w/edit/cSysProg Edit]