#summary ภาษา C กับ System Programming
<table width=500>
<td>
[CourseSchedule2555_2 กลับไปหน้าหลัก]-->[<a href="https://code.google.com/p/system-programming-cs3402-at-crma/wiki/CourseSchedule2555_2#ตารางเรียน_๒๕๕๕/๒">ตารางเรียน</a>]-->Next: [cSysProg C กับ System Programming]
<wiki:toc max_depth="3" />

==inode==
inode, index node (ดัชนีโหนด)เป็นเลขรหัสของไฟล์ที่มีในระบบไฟล์ของระบบปฏิบัติการ Unix หรือ Linux ระบบปฏิบัติการจะมองทรัพยากรหรือวัตถุทุกอย่างเป็นไฟล์ และใช้เลข inode ในการอ้างอิงไฟล์ โดย inode จะเก็บข้อมูลต่าง ๆ เกี่ยวกับไฟล์ หรือที่เรียกว่า meta-data เช่น ชนิดของไฟล์, ชื่อเจ้าของ, ชื่อกลุ่ม, ขนาดไฟล์, สิทธิ์ในใช้ไฟล์, เวลาในการอ่านและเขียนไฟล์ (UNIX  และ Linux จะไม่เก็บเวลาในการสร้างไฟล์), เวลาในการลบไฟล์ เป็นต้น

 * เลข inode จะไม่ซ้ำกัน

===คำสั่งที่ใช้ดูเลข inode===

{{{
$ ls -i /etc/passwd
}}}

===การประยุกต์ใช้ inode===

{{{
$ cd /tmp
$ ls -l
}}}

จะได้ผลลัพธ์ดังนี้
{{{
prachya@pcubusrv104> ls -l
total 8
-rw-r--r-- 1 prachya prachya 2082 2012-11-14 16:51 gchart-disk.pl
-rw-r--r-- 1 prachya prachya    6 2012-11-05 13:34 junk
}}}
ในที่นี้ ls จะแสดงรายละเอียดของไฟล์แต่ไม่แสดง inode โดยที่ total 8 ในที่นี้หมายถึงจำนวน blocks ที่ถูกใช้ในไดเร็กทอรี่/ไฟล์นี้ (สามารถตรวจสอบดูได้ด้วยคำสั่ง ls -s ซึ่งจะแสดงจำนวน blocks ที่ใช้ในแต่ละไฟล์/ไดเร็กทอรี่

ในกรณีที่เราต้องการดูรายละเอียดของ index ของ inode สามารถใช้ตัวเลือก -i เพื่อให้แสดงข้อมูลของ inode ได้
{{{
$ ls -il /tmp
}}}
จะได้ผลลัพธ์ดังนี้
{{{
prachya@pcubusrv104> ls -il /tmp
total 8
2496286 -rw-r--r-- 1 prachya prachya 2082 2012-11-14 16:51 gchart-disk.pl
2101314 -rw-r--r-- 1 prachya prachya    6 2012-11-05 13:34 junk
}}}

===stat แสดง inode===
โปรแกรม stat จะแสดงรายละเอียดต่าง ๆ ของไฟล์/ไดเร็กทอรี่ รวมถึงข้อมูลของ inode ดังตัวอย่าง

{{{
prachya@pcubusrv104> stat /tmp/junk
  File: `/tmp/junk'
  Size: 6               Blocks: 8          IO Block: 4096   regular file
Device: 803h/2051d      Inode: 2101314     Links: 1
Access: (0644/-rw-r--r--)  Uid: ( 1001/ prachya)   Gid: ( 1001/ prachya)
Access: 2012-11-05 13:34:21.479437961 +0700
Modify: 2012-11-05 13:34:03.455437909 +0700
Change: 2012-11-05 13:34:03.455437909 +0700
}}}

===C โปรแกรมที่เข้าถึง inode===

ตัวอย่างโปรแกรมภาษา C ต่อไปนี้ใช้ไลบรารี่ fstat() เพื่อเรียกดูข้อมูลของไฟล์/ไดเร็กทอรี่
รูปแบบของ fstat()
{{{
int fstat(int fildes, struct stat *buf);
}}}
โดยที่

||Field||Description||
||int fildes||	The file descriptor of the file that is being inquired.||
||{{{struct stat *buf}}} ||	A structure where data about the file will be stored. A detailed look at all of the fields in this structure can be found in the struct stat page. ||
||return value||	Returns a negative value on failure.||

ดูรายละเอียดของ sys/stat.h ได้ด้วยคำสั่ง
{{{
man -s 2 stat
}}}

{{{
// test-fstat.c
#include <unistd.h>
#include <fcntl.h>
#include <stdio.h>
#include <sys/stat.h>
#include <sys/types.h>
 
int main(int argc, char **argv)
{
    if(argc != 2)    
        return 1;
 
    int file=0;
        if((file=open(argv[1],O_RDONLY)) < -1)
            return 1;
 
    struct stat fileStat;
    if(fstat(file,&fileStat) < 0)    
        return 1;
 
    printf("Information for %s\n",argv[1]);
    printf("---------------------------\n");
    printf("File Size: \t\t%d bytes\n",fileStat.st_size);
    printf("Number of Links: \t%d\n",fileStat.st_nlink);
    printf("File inode: \t\t%d\n",fileStat.st_ino);
 
    printf("File Permissions: \t");
    printf( (S_ISDIR(fileStat.st_mode)) ? "d" : "-");
    printf( (fileStat.st_mode & S_IRUSR) ? "r" : "-");
    printf( (fileStat.st_mode & S_IWUSR) ? "w" : "-");
    printf( (fileStat.st_mode & S_IXUSR) ? "x" : "-");
    printf( (fileStat.st_mode & S_IRGRP) ? "r" : "-");
    printf( (fileStat.st_mode & S_IWGRP) ? "w" : "-");
    printf( (fileStat.st_mode & S_IXGRP) ? "x" : "-");
    printf( (fileStat.st_mode & S_IROTH) ? "r" : "-");
    printf( (fileStat.st_mode & S_IWOTH) ? "w" : "-");
    printf( (fileStat.st_mode & S_IXOTH) ? "x" : "-");
    printf("\n\n");
 
    printf("The file %s a symbolic link\n\n", (S_ISLNK(fileStat.st_mode)) ? "is" : "is not");
 
    return 0;
}
// source: http://codewiki.wikidot.com/c:system-calls:fstat
}}}

คอมไพล์โปรแกรมด้วยคำสั่ง 
{{{
gcc test-fstat.c -o test-fstat
}}}
ทดสอบการทำงาน
{{{
prachya@pcubusrv104> ./test-fstat /tmp/junk
Information for /tmp/junk
---------------------------
File Size:              6 bytes
Number of Links:        1
File inode:             2101314
File Permissions:       -rw-r--r--

The file is not a symbolic link
}}}

==FILE I/O==
การเขียนโปรแกรมติดต่อไฟล์บนระบบปฏิบัติการ Linux นั้นจำเป็นจะต้องมีการเปิดไฟล์ก่อน ซึ่งตัว kernel ได้สร้าง List ของไฟล์ที่เปิดอยู่ไว้ให เรียกว่า File Table ซึ่งใน File Table จะมีเลขดัชนีที่ไม่มีค่าติดลบ เรียกว่า File Descriptor (fds) ซึ่งจะมีรายละเอียดต่าง ๆ เกี่ยวกับการเปิดไฟล์ รวมถึงรายละเอียดเกี่ยวกับหน่วยความจำที่ใช้ในการเปิดไฟล์ด้วย

==system call function==
เป็นฟังก์ชันระดับ Low-Level ของระบบปฏิบัติการ ซึ่งมีความรวดเร็วสูงในการทำงาน แต่มีข้อจำกัดคือฟังก์ชันจะผูกกับระบบปฏิบัติการนั้น ๆ และการใช้งานค่อนข้างยุ่งยาก

==open( ) System Call ==
เป็น system call ที่ใช้สำหรับเปิดไฟล์
{{{
#include <sys/types.h> 
#include <sys/stat.h> 
#include <fcntl.h> 
int open (const char *name, int flags); 
int open (const char *name, int flags, mode_t mode);
}}}

ตัวอย่างการใช้ open() System Call
{{{
int fd; 
fd = open ("/home/kidd/madagascar", O_RDONLY); 
if (fd == -1) 
/* error */ 
}}}

==Flag ของ open() System Call ที่น่าสนใจ==
 * O_APPEND
The file will be opened in append mode. That is, before each write, the file 
position will be updated to point to the end of thefile. This occurs even if another 
process has written to the file after the issuing process' last write, thereby 
changing the file position. (See "Section 2.3.2" later in this chapter). 
 * O_ASYNC
A signal (SIGIOby default) will be generated when the specified file becomes 
readable or writable. This flag is available only for terminals and sockets, not for 
regular files. 
 * O_CREAT
If the file denoted by namedoes not exist, the kernel will create it. If the file 
already exists, this flag has no effect unless O_EXCLis also given. 
Linux System Programming 
38 of 396 
 * O_DIRECT
The file will be opened for direct I/O (see "Section 2.5" later in this chapter). 
 * O_DIRECTORY
If nameis not a directory, the call to open( )will fail. This flag is used internally 
by the opendir( )library call. 
 * O_EXCL
When given with O_CREAT, this flag will cause the call to open( )to fail if the file 
given by namealready exists. This is used to prevent race conditions on file 
creation. 
 * O_LARGEFILE
The given file will be opened using 64-bit offsets,allowing files larger than two 
gigabytes to be opened. This is implied on 64-bit architectures. 
 * O_NOCTTY
If the given namerefers to a terminal device (say, /dev/tty), it will not become 
the process' controlling terminal, even if the process does not currently have a 
controlling terminal. This flag is not frequently used. 
 * O_NOFOLLOW
If nameis a symbolic link, the call to open( )will fail. Normally, the link is 
resolved, and the target file is opened. If other components in the given path are 
links, the call will still succeed. For example, if nameis /etc/ship/plank.txt, the 
call will fail if plank.txtis a symbolic link. It will succeed, however, if etcor ship
is a symbolic link, so long as plank.txtis not. 
 * O_NONBLOCK 
If possible, the file will be opened in nonblockingmode. Neither the open( )call, 
nor any other operation will cause the process to block (sleep) on the I/O. This 
behavior may be defined only for FIFOs. 
 * O_SYNC
The file will be opened for synchronous I/O. No write operation will complete until 
the data has been physically written to disk; normal read operations are already 
synchronous, so this flag has no effect on reads. POSIX additionally defines 
O_DSYNC and O_RSYNC; on Linux, these flags are synonymous with O_SYNC.    

 * O_TRUNC
If the file exists, it is a regular file, and the given flags allow for writing, the file 
will be truncated to zero length. Use of O_TRUNCon a FIFO or terminal device is 
ignored. Use on other file types is undefined. Specifying O_TRUNCwith O_RDONLY
is 
also undefined, as you need write access to the file in order to truncate it. 
For example, the following code opens for writing thefile /home/teach/pearl. If the file 
already exists, it will be truncated to a length of zero. Because the O_CREAT flag is not 
specified, if the file does not exist, the call will fail: 
{{{
int fd; 
fd = open ("/home/teach/pearl", O_WRONLY | O_TRUNC); 
if (fd == -1) 
/* error */ 
}}}
==close( ) System Call ==
เป็น system call ที่ใช้สำหรับปิดไฟล์
รูปแบบของ close()
{{{
#include <unistd.h> 
int close (int fd);
}}}
ตัวอย่างการใช้งานของ close() System Call
{{{
if (close (fd) == -1) 
perror ("close"); 
}}}

=References=
  # Wiil-Hans Steeb, et al, _Linux, Shell Programming and Perl_ (Chapter 2 File I/O) [http://issc.uj.ac.za/downloads/linux.pdf  [PDF]]
----
[CourseSchedule2555_2 กลับไปหน้าหลัก]-->[<a href="https://code.google.com/p/system-programming-cs3402-at-crma/wiki/CourseSchedule2555_2#ตารางเรียน_๒๕๕๕/๒">ตารางเรียน</a>]-->Next: [cSysProg C กับ System Programming]

[https://code.google.com/p/system-programming-cs3402-at-crma/w/edit/cSysProg Edit]