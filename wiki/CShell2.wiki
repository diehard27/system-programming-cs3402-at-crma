#summary C กับการติดต่อกับ Shell 2
<table width=500>
<td>
[CourseSchedule2555_2 กลับไปหน้าหลัก]-->[<a href="https://code.google.com/p/system-programming-cs3402-at-crma/wiki/CourseSchedule2555_2#ตารางเรียน_๒๕๕๕/๒">ตารางเรียน</a>]-->Next: [cSysProg C กับ System Programming]
<wiki:toc max_depth="3" />

== Permission ==
ภาษาซีมีฟังก์ชัน chmod และ fchmod ที่ใช้ในการกำหนด permission ให้ไฟล์ โดยมีรูปแบบดังนี้
{{{
#include <sys/types.h> 
#include <sys/stat.h> 
int chmod (const char *path, mode_t mode); 
int fchmod (int fd, mode_t mode);
}}}
ทั้ง chmod และ  fchmod สามารถใช้ set permission ได้เหมือนกัน ต่างกันตรงที่ chmod ใช้กับ absolute path name แต่ fchmod ใช้กับ file descriptor

flag สำหรับ chmod มีดังนี้
||Flag||Octal value||Purpose||
||S_ISUID||04000||Set user ID on execution||
||S_ISGID||02000||Set group ID on execution||
||S_ISVTX||01000||Sticky bit||
||S_IRUSR, S_IREAD||00400||Read by owner||
||S_IWUSR, S_IWRITE||00200||Write by owner||
||S_IXUSR, S_IEXEC||00100||Execute/search by owner||
||S_IRGRP||00040||Read by group||
||S_IWGRP||00020||Write by group||
||S_IXGRP||00010||Execute/search by group||
||S_IROTH||00004||Read by others||
||S_IWOTH||00002||write by others||
||S_IXOTH||00001||Execute/search by others||

ตัวอย่างของการใช้งาน chmod() แสดงได้ดังโค้ดด้านล่าง
{{{
  1 #include <sys/types.h>
  2 #include <sys/stat.h>
  3 #include <stdio.h>
  4 #include <errno.h>
  5 #include <errno.h>
  6
  7 int main(int argc,char* argv[]){
  8
  9           int rc;
 10
 11           rc = chmod(argv[1], 0444);
 12           if (rc == -1)
 13              fprintf(stderr, "chmod failed, errno = %d\n", errno);
 14         return 0;
 15 }
}}}

ตังอย่างของการใช้งาน fchmod() แสดงได้ดังโค้ดด้านล่าง
{{{
int ret; 
/* 
* Set the file behind 'fd' to owner-readable 
* and -writable. 
*/ 
ret = fchmod (fd, S_IRUSR | S_IWUSR); 
if (ret) 
perror ("fchmod"); 
}}}
ถ้า chmod() และ fchmod() ทำงานสำเร็จจะ return 0 แต่ถ้าไม่สำเร็จ จะ return -1 รายละเอียดของ error สามารถดูได้จากค่าของตัวแปร errno


== Reading the directory's content ==
ภาษาซี จะมอง content ของ directory เป็น stream ก่อนจะเริ่มอ่าน content จาก directory จะต้องทำการสร้าง directory stream เสียก่อน ซึ่งแทนด้วยการประการ Object ชื่อ *DIR* 
ภาษาซี ใช้ ตัวแปรโครงสร้าง (struct) dirent ซึ่งอยู่ใน library <dirent.h> ในการเก็บข้อมูลต่าง ๆ ของ content ใน directory โดยรายละเอียดของ struct dirent แสดงได้ตามโค้ดด้านล่าง
{{{
struct dirent { 
ino_t d_ino; /* inode number */ 
off_t d_off; /* offset to the next dirent */ 
unsigned short d_reclen; /* length of this record */ 
unsigned char d_type; /* type of file */ 
char d_name[256]; /* filename */ 
};
}}}
ในการอ่าน content ใน directory ด้วยภาษาซี จะใช้ฟังกชันหลัก ๆ 3 function ได้แก่ opendir(), readdir(), และ closedir() โดยรูปแบบการใช้งานของแต่ละฟังก์ชันแสดงได้ตามโค้ดด้านล่าง
รูปแบบการใช้งาน ฟังก์ชัน opendir()
{{{
#include <sys/types.h> 
#include <dirent.h> 
DIR * opendir (const char *name);
}}}

รูปแบบการใช้งานฟังก์ชัน readdir()
{{{
#include <sys/types.h> 
#include <dirent.h> 
struct dirent * readdir (DIR *dir);
}}}

รูปแบบการใช้งานฟังก์ชัน closedir()
{{{
#include <sys/types.h> 
#include <dirent.h> 
int closedir (DIR *dir);
}}}
ตัวอย่างนการเรียกใช้งานฟังก์ชันในการอ่าน content ใน directory แสดงได้ดังโค้ดด้านล่าง
{{{
 //Source code produced by Adri Jovin.J.J
  9 #include<stdio.h>
 10 #include<dirent.h>
 11 #include<stdlib.h>
 12 struct dirent *dptr;
 13 int main(int argc, char *argv[])
 14 {
 15         char buff[256];
 16         DIR *dirp;
 17         printf("\n\n Enter directory Name");
 18         scanf("%s",buff);
 19         if((dirp=opendir(buff))==NULL)
 20         {
 21                 printf("Error");
 22                 exit(1);
 23         }
 24         while(dptr=readdir(dirp))
 25         {
 26                 printf("%s\n",dptr->d_name);
 27         }
 28         closedir(dirp);
 29 }
}}}
== Memory Management ==
===Allocate Dynamic Memory===
โดยทั่วไปการใช้งาน memory จะเป็นแบบคงที่ แต่มีบ่อยครั้งในการเขียนโปรแกรมที่เรายังไม่ทราบจะต้องใช้ memory เท่าไร หรือต้องการใช้ memory เพิ่มในระหว่างรันโปรแกรม เนื่องจาก memory ที่ให้มาไม่เพียงพอ ภาษาซีได้จัดเตรียมฟังก์ชันสำหรับจอง memory ในระหว่างรันโปรแกรมไว้ให้ ทำให้เรามีความยืดหยุ่น (dynamic) ในการใช้งาน memory ได้มากยิ่งขึ้น ฟังก์ชันที่น่าสนใจสำหรับจัดการหน่วยความจำได้แก่ malloc(),realloc(), และ free()
malloc เป็นฟังก์ชันที่ใช้จองหน่วยความจำ โดยจะ return pointer ที่ชี้ไปยังหน่วยความจำใหม่ที่จองไว้ให้ตามที่ขนาดที่ระบุไว้ในฟังก์ชัน  ซึ่งมีรูปแบบการใช้งานดังนี้
{{{
#include <stdlib.h> 
void * malloc (size_t size);
}}}

realloc() เป็นฟังก์ชันที่ใช้ในการปรับเปลี่ยนหน่วยความจำที่ขอไว้ รูปแบบการใช้งานมีดังนี้
{{{
#include <stdlib.h> 
void * realloc (void *ptr, size_t size); 
}}}

free() เป็นฟังก์ชันที่ใช้ในคืนหน่วยความเมื่อเลิกใช้งานแล้ว รูปแบบการใช้งานมีดังนี้
{{{
#include <stdlib.h> 
void free (void *ptr);
}}}
ตัวอย่างการใช้งาน malloc แสดงได้ดังโค้ดด้านล่าง
{{{
// code by http://www.codingunit.com/c-tutorial-the-functions-malloc-and-free
  1 #include<stdio.h>
  2 #include<stdlib.h>
  3         int main()
  4         {
  5                 int *ptr_one;
  6
  7                 ptr_one = (int *)malloc(sizeof(int));
  8
  9                 if (ptr_one == 0)
 10                 {
 11                         printf("ERROR: Out of memory\n");
 12                         return 1;
 13                 }
 14
 15                 *ptr_one = 25;
 16                 printf("%d\n", *ptr_one);
 17
 18                 free(ptr_one);
 19
 20                 return 0;
 21         }
}}}
ตัวอย่างการใช้งาน realloc() แสดงได้ดังโค้ดด้านล่าง
{{{
  // code by http://www.codingunit.com/c-reference-stdlib-h-function-realloc
  1 #include<stdio.h>
  2 #include<stdlib.h>
  3 int main ()
  4 {
  5         int * buffer;
  6         /*get a initial memory block*/
  7         buffer = (int*) malloc (10*sizeof(int));
  8         if (buffer==NULL)
  9         {
 10                 printf("Error allocating memory!");
 11                 exit (1);
 12         }
 13         /*get more memory with realloc*/
 14         buffer = (int*) realloc (buffer, 20*sizeof(int));
 15         if (buffer==NULL)
 16         {
 17                 printf("Error reallocating memory!");
 18                 //Free the initial memory block.
 19                 free (buffer);
 20                 exit (1);
 21         }
 22         free (buffer);
 23         printf ("realloc complete\n");
 24         return 0;
 25 }
}}}
== struct mallinfo()==
ใช้สำหรับดูสถิติการใช้ memory ซึ่ง struct mallinfo จะประกาศอยู่ใน library "malloc.h" ซึ่งรายละเอียดของ struct mallinfo() สามารถแสดงได้ดังโค้ดด้านล่าง
{{{
/* all sizes in bytes */ 
struct mallinfo { 
int arena; /* size of data segment used by malloc */ 
int ordblks; /* number of free chunks */ 
int smblks; /* number of fast bins */ 
int hblks; /* number of anonymous mappings */ 
int hblkhd; /* size of anonymous mappings*/ 
int usmblks; /* maximum total allocated size */ 
int fsmblks; /* size of available fast bins */ 
int uordblks; /* size of total allocated space */ 
int fordblks; /* size of available chunks */ 
int keepcost; /* size of trimmable space */
};
}}}
===ฟังก์ชัน malloc_stats()=== 
อยู่ใน library malloc.h เช่นกัน ใช้แสดงรายละเอียดที่เกี่ยวเนื่องกับการใช้ memory รูปแบบการใช้งานมีดังนี้
{{{
#include <malloc.h> 
void malloc_stats (void);
}}}

ตัวอย่างการใช้งาน mallinfo และ malloc_stats()  สามารถแสดงได้ดังโค้ดด้านล่าง
{{{
  1 #include <stdio.h>
  2 #include <stdlib.h>
  3 #include <malloc.h>
  4
  5 int main (void){
  6
  7         struct mallinfo m;
  8         m = mallinfo ( );
  9          printf ("free chunks: %d\n", m.ordblks);
 10         malloc_stats();
 11         return 0;
 12 }

}}}
== Signal ==
เป็นสัญญาณที่สร้างขึ้นโดยระบบปฏิบัติการ UNIX การส่ง Signal มีอยู่สองลักษณะ ได้แก่
 # kernel ส่งไปยัง process
    Ctrl+C , Ctrl+Delete SIGINT
    Ctrl+backslash SIGQUIT
    Ctrl+Z  SIGTSTP
 # process ส่งไปยัง process
    เช่น การใช้ command line kill -9 <pid>
       การใช้ ฟังก์ชัน int kill(int pid, int sig);
ภาษาซีได้จัดเตรียมฟังก์ชัน ที่ใช้จัดการกับ signal ไว้ใน library "signal.h" โดยฟังก์ชันที่น่าสนใจได้แก่ signal ซึ่งมีรูปแบบการใช้งานดังนี้
{{{
#include <signal.h>
int (*signal (int sig, void (*func)(int) ) ) (int);
}}}
โดยที่ 
 * sig        ระบุสัญญาณที่ได้รับ
 * void func  ฟังก์ชันที่ทำงานเมื่อได้รับสัญญาณโดยไม่มีการส่งค่ากลับ
 * int        ฟังก์ชันที่มีอาร์กิวเมนต์สำหรับรับข้อมูลโดยเป็นหมายเลขของสัญญาณ

ฟังก์ชัน signal
จะส่งค่ากลับเป็นค่าที่ได้กำหนดไว้ตั้งแต่การทำงานครั้งสุดท้าย
หรืออาจใดค่าหนึ่งต่อไปนี้

 * SIG_IGN  เพิกเฉยต่อสัญญาณ
 * SIG_DFL  ย้อนกลับการทำงานที่เป็นค่าปริยาย

รายชื่อสัญญาณ ที่กำหนดไว้ใน signal.h มีดังนี้
||SIGALRM||เกิดขึ้นมาโดย timer โดยใช้ฟังก์ชัน alarm ใช้สำหรับกำหนดเวลาของโปรเซส (ไม่ใช่เวลาที่ใช้งานCPU) ส่วนใหญ่จะใช้กำหนดเวลาหมดการทำงานของโปรเซส||
||SIGHUP||จะส่งไปยังโปรเซสเมื่อเทอร์มินอลยกเลิกการใช้งาน||
||SIGINT||จะเกิดขึ้นเมื่อกดคีย์อินเตอร์รัพ (Ctrl-C) บนเทอร์มินอลหรืออักษรอื่นที่กำหนดไว้||
||SIGKILL||จะบังคับให้โปรเซสหยุดการทำงานเนื่องจากโปรเซสไม่สามารถจะทำงานอื่นหรือเฉยต่อสัญญาณนี้ได้||
||SIGTSTP||จะส่งไปยังโปรเซสเมื่อกดคีย์ Ctrl-Z หรือ Ctrl-Y โปรเซสหยุดการทำงานเนื่องจากสัญญาณนี้สามารถทำงานต่อด้วยสัญญาณ SIGCONT||
||SIGCONT||ถ้าโปรเซสหยุดทำงานให้เริ่มรันโปรเซสโปรเซสต่อไป||
||SIGILL||ระบุว่ามีการใช้คำสั่งที่ไม่ถูกต้อง||
||SIGQUIT||ปรกติจะเกิดขึ้นเมื่อเทอร์มินอล Ctrl-\ หรืออักษรที่กำหนดไว้||
||SIGTERM||แจ้งให้โปรเซสหยุดทำงานเป็นสัญญาณที่ส่งไปให้โปรแกรมเมื่อใช้คำสั่ง kill||
||SIGABORKT||สร้างขึ้นเมื่อเกิดข้อผิดพลาดจากการทำงานของฮาร์ดแวร์และส่งไปยังโปรเซสเองเพื่อหยุดทำงาน||
||SIGSEGV||ขึ้นอยู่กับฮาร์ดแวร์เมื่อมีแอ็คเซสพื้นที่หน่วยความจำที่ไม่ถูกต้องโครงสร้างในการจัดการหน่วยความจำเสียหาย||
||SIGCHLD||ส่งไปยังโปรเซสต้นฉบับเมื่อโปรเซสลูกหยุดทำงานหรือเมื่อพบคำสั่ง exit||
||SIGSTOP||สั่งให้โปรเซสหยุดรันโดยโปรเซสที่ได้รับสัญญาณนี้จะสามารถรันต่อไปได้ด้วยสัญญาณ SIGCONT||

ฟังก์ชันที่ใช้สำหรับจัดการกับ signal มีดังนี้
||signal()||จะติดตั้งตัวควบคุมสัญญาณขึ้นมาใหม่สำหรับสัญญาณโดยตัวควบคุมสัญญาณที่ติดตั้งจะอยู่ในรูปของตัวเลขสัญญาณตัวควบคุมสัญญาณจะติดตั้งเพื่อ sighandler ซึ่งฟังก์ชันนี้อาจจะสร้างขึ้นโดยผู้ใช้หรือสัญญาณอื่นๆ||
||pause()||ทำให้โปรแกรมหยุดทำงานจนกระทั่งเกิดสัญญาณบางอย่างจึงจะรันต่อ||
||sigfillset()||เริ่มต้นใช้งานตัวแปรต่อชุดสัญญาณที่กำหนด||
||sigprocmask()||กำหนดหรือตรวจสอบสัญญาณที่ถูกบล็อกสำหรับโปรเซสที่กำลังรันเพื่อป้องกันไม่ให้โปรเซสรับสัญญาณ||
||kill()||ใช้ฆ่าโปรเซสโดยการส่งสัญญาณถึงโปรเซส||
||alarm()||กำหนดช่วงเวลาที่เคอร์เนลจะส่งสัญญาณ SIGALRM ไปยังโปรเซส||
ตัวอย่างการใช้งานฟังก์ชัน signal แสดงได้ดังโค้ดด้านล่าง
{{{
// code by http://lecture.cs.buu.ac.th/~s47232/special_report/new/signal.doc
  1 #include <stdio.h>      /* standard I/O functions */
  2 #include <unistd.h>    /* standard unix functions, like getpid() */
  3 #include <signal.h>    /* signal name macros, and the signal() prototype */
  4
  5 /* first, here is the signal handler */
  6 void catch_int(int sig_num)
  7 {
  8     /* re-set the signal handler again to catch_int, for next time */
  9     signal(SIGINT, catch_int);
 10     printf("Don't do that\n");
 11     fflush(stdout);
 12 }
 13
 14
 15 int main(int argc, char* argv[])
 16 {
 17     /* set the INT (Ctrl-C) signal handler to 'catch_int' */
 18     signal(SIGINT, catch_int);
 19
 20     /* now, lets get into an infinite loop of doing nothing. */
 21     for ( ;; )
 22         pause();
 23 }

}}}



=References=
  # Wiil-Hans Steeb, et al, _Linux, Shell Programming and Perl_ [http://issc.uj.ac.za/downloads/linux.pdf  PDF]
  # Ananda Gunawardena, _Process Control_ [http://www.cs.cmu.edu/~guna/15-123S11/Lectures/Lecture25.pdf PDF]
  # March H. Scholl, _Process Control Subsystem_ [http://www.inf.uni-konstanz.de/dbis/teaching/ss09/os/L2.pdf PDF]
 
 
----
[CourseSchedule2555_2 กลับไปหน้าหลัก]-->[<a href="https://code.google.com/p/system-programming-cs3402-at-crma/wiki/CourseSchedule2555_2#ตารางเรียน_๒๕๕๕/๒">ตารางเรียน</a>]-->Next: [cSysProg C กับ System Programming]

[https://code.google.com/p/system-programming-cs3402-at-crma/w/edit/CShell2 Edit]