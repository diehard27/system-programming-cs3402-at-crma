#summary C กับการติดต่อกับ Shell
<table width=500>
<td>
[CourseSchedule2555_2 กลับไปหน้าหลัก]-->[<a href="https://code.google.com/p/system-programming-cs3402-at-crma/wiki/CourseSchedule2555_2#ตารางเรียน_๒๕๕๕/๒">ตารางเรียน</a>]-->Next: [cSysProg C กับ System Programming]
<wiki:toc max_depth="3" />

==Process==
 ความหมายของ Process ที่ถูกใช้บ่อย ๆ คือ "โปรแกรมที่กำลังประมวลผลอยู่" โดยคำว่า process จะมีความหมายเช่นเดียวกับ job หรือ task โดยในแต่ละ Process จะมีรายละเอียดต่าง ๆ ดังนี้
 * ทุก ๆ Process จะมี "process ID" ซึ่งเป็นเลขไม่ซ้ำกัน (Unique)
 * process ID จะมีค่าเป็นเลขจำนวนเต็มบวกเสมอ
 * ถึงแม้ processID จะไม่ซ้ำกัน, แต่เลข process ID จะถูกนำกลับมาใช้ใหม่ได้
 * แต่ละ processID จะมีสถานะในการประมวลผล (state)
ในระบบที่มีตัวประมวลผลเดียว ก็ยังสามารถรันหลาย ๆ process ได้ในเวลาเดียวกัน เช่นเดียวกับระบบที่มีตัวประมวลผลหลายตัว การเรียกโปรแกรมให้ทำงานเป็นการเริ่มต้นการสร้าง process เมื่อโปรแกรมถูกรัน process จะถูกสร้างขึ้นและมีการจ่าย processID ให้กับ process นั้น โดยฟังก์ชัน getpid() จะสามารถแสดง processID ของ process ที่กำลังรันอยู่ได้

==ฟังก์ชัน getpid()==
เป็นฟังก์ชันที่อยู่ใน library <unistd.h> ใช้ในแสดงเลข processID ของโปรแกรมที่กำลังทำงานอยู่

ตัวอย่างการทำงานของ getpid() แสดงดังโค้ดด้านล่าง

{{{
  1 //getpid.c
  2 #include <stdio.h>
  3 #include <unistd.h>
  4 int main(void){
  5         printf("Hello, this is process ID %d\n",getpid());
  6         return 0;
  7 }

}}}
โดยปกติแล้ว ProcessID จะถูกตั้งค่าสูงสุดไว้ที่ 32768 เพื่อรองรับกับระบบปฏิบัติการ UNIX แบบเก่าที่ใช้สถาปัตยกรรม 16 บิต อย่างไรก็ตาม เราสามารถเข้าไปแก้ไขค่า Maximum processID ได้ ที่  /proc/sys/kernel/pid_max


ในเครื่องที่มีตัวประมวลผลเดี่ยว แต่ละ Process จะถูกเรียกเข้ามาประมวลผล ในช่วงเวลาอันสั้น เราสามารถใช้คำสั่ง ps สำหรับแสดง processID ทั้งหมดที่กำลังทำงานอยู่ได้ โดยคำสั่ง ps จะแสดง ProcessID, ชื่อของ terminal(TTY), เวลาที่ Process ใช้ในการประมวลผล (TIME), และคำสั่งที่กำลังประมวลผลอยู่ (CMD)

{{{
$ ps
  PID TTY          TIME CMD
 6506 pts/2    00:00:00 bash
 6573 pts/2    00:00:00 ps

}}}
 อย่างไรก็ตาม คำสั่ง ps จะแสดงเฉพาะ Process ของผู้ใช้ที่กำลังประมวลผลอยู่ ณ ปัจจุบัน แต่เราสามารถใช้ flag เพื่อให้แสดง process ทั้งหมดได้ด้วย flag "-a", และยังสามารถแสดงข้อมูล process ในแบบเต็มรูปได้ด้วย flag "-l"

ข้อมูลเพิ่มเติมของแต่ละ process ได้แก่
||PID|| เลข processID ที่เป็นเลขจำนวนเต็มบวก||
||PPID|| เลข processID แม่ (Parent Process) ที่เป็นเลขจำนวนเต็มบวก||
||STAT|| สถานะของ Process||
||TIME|| CPU Time ที่ process ใช้ (เป็นวินาที)||
||TT|| ชื่อ control terminal ของ Process||
||CMD|| คำสั่งของผู้ใช้ ที่เป็นตัวเริ่ม Process||

==Process Hierachy==
ในแต่ละ Process จะมี Parent Process (process แม่) ซึ่งก็คือ Process ที่ได้สร้าง Process ใหม่ขึ้นมารัน ส่วน Process ที่ถูก Parent สร้างขึ้นมา จะเรียกว่า Child Process (process ลูก) ค่าที่ใช้บ่งบอกความสัมพันธ์ระหว่าง parent กับ child ได้แก่  ppid (Parent Process ID) ซึ่งจะเก็บค่า pid ของ process ที่เป็น parent ของ process นั้น ฟังก์ชันที่ใช้สำหรับแสดง ppid ได้แก่ getppid()

===pid_t===
pid_t เป็น type ของ processID ซึ่งถูกประกาศไว้ใน library <sys/types.h> ซึ่งโดยทั่วไปแล้ว ชนิดของ pid_t จะเป็น Integer

==ฟังก์ชัน getppid()==
เป็นฟังก์ชันที่อยู่ใน library <unistd.h> ใช้ในแสดงเลข processID ของโปรแกรมที่กำลังทำงานอยู่

ตัวอย่างการทำงานของ getppid() แสดงดังโค้ดด้านล่าง

{{{
  1 //getppid.c
  2 #include <stdio.h>
  3 #include <unistd.h>
  4 int main(void){
  5         printf("Hello, this is process ID %d\n",getpid());
  6         printf("Hello, this is my parent ID %d\n",getppid());
  7         return 0;
  8 }

}}}

===Process Tree===
คำสั่ง ps สามารถแสดงรายละเอียดเชิงกราฟต้นไม้ของโพรเซสได้ ซึ่งจะทำให้ผู้ใช้เห็นความสัมพันธ์ของการแตก (fork) โพรเซสลูกออกมา ตามตัวอย่างต่อไปนี้

{{{
prachya@pcubusrv104> ps --forest -aux |grep prachya
Warning: bad ps syntax, perhaps a bogus '-'? See http://procps.sf.net/faq.html
root      8330  0.0  0.2  12852  4380 ?        Ss   11:03   0:00  \_ sshd: prachya [priv]
prachya   8401  0.0  0.0  12852  1856 ?        S    11:03   0:00      \_ sshd: prachya@pts/1
prachya   8402  0.0  0.1   5824  3200 pts/1    Ss   11:03   0:00          \_ -bash
prachya   8532  0.0  0.0   2708  1052 pts/1    R+   11:11   0:00              \_ ps --forest -aux
prachya   8533  0.0  0.0   3320   800 pts/1    S+   11:11   0:00              \_ grep --color=auto prachya
prachya   1164  0.0  0.1   5880  3240 tty2     S    Nov30   0:00  \_ -bash
prachya    919  0.0  0.1   5880  3240 tty1     S    Nov30   0:00  \_ -bash
}}}

จากผลการรัน {{{ps --forest -aux |grep prachya }}} จะแสดงต้นไม้ของโพรเซสที่เกี่ยวข้องกับผู้ใช้ prachya ยกตัวอย่างเช่น ผู้ใช้ล็อกอินเข้าระบบด้วย ssh และได้รัน bash (8402) เพื่อให้รับคำสั่งผ่านคีย์บอร์ดและแสดงผลออกเทอมินอล ในเชลล์่ที่มีหมายเลขโพรเซส 8402 ของผู้ใช้นี้ ได้ fork โพรเซสของคำสั่ง ps และคำสั่ง grep หมายเลขโพรเซส 8532 และ 8533 ตามลำดับ คำสั่ง ps ที่ใช้ตัวเลือก --forest ทำให้เห็นความสัมพันธ์ของการรันโพรเซสได้เป็นอย่างดี

==Background Process==
Backgroud Process จะทำงานอยู่เบื้องหลังไปเรื่อย ๆ แม้กระทั่ง ที่มีการ logout ออกจากระบบ การรันโปรแกรมให้มีลักษณะเป็น Background process ทำได้โดยใช้เครื่องหมาย & ตามหลังโปรแกรมที่รันดังนี้
{{{
./perl stack.pl &
}}}
วิธีการตรวจสอบว่า โปรแกรมยังรันอยู่หลังจาก logout หรือไม่ ให้ logout ออกจากระบบ แล้ว login เข้าไปใหม่ แล้วทดลองใช้คำสั่ง ps ดูว่ายังมีโปรแกรม รันอยู่หรือเปล่า


==Running a New Process==
ในระบบปฏิบัติการ Unix จะแยกการ execute program ออกจากการสร้าง(create) process ใหม่ การ execute program คือ การที่ system call หนึ่งทำการโหลดโปรแกรมที่เป็น binary ลงในหน่วยความจำ แล้วแทนที่เนื้อหาต่าง ๆ ในหน่วยความจำ และเริ่มให้ program ทำงานใหม่ โดยสามารถเรียกใช้ function ในกลุ่ม exec (exec family) สำหรับการ execute โปรแกรมใหม่ได้

ในขณะที่การสร้าง process ใหม่ เริ่มต้นจะมีการสร้าง process ลูกขึ้นมาใหม่ โดยคุณสมบัติของ process ลูกจะลอกเลียนมาจากคุณสมบัติของ process แม่ทุกประการ แต่มี pid, พื้นที่หน่วยความจำ,เวลาในการใช้ CPU, และ state เป็นของตัวเอง จากนั้นก็จะทำการ execute program ใหม่ เรียกพฤติกรรมแบบนี้ว่า "fork" ซึ่งจะทำให้โปรแกรมสามารถทำงานได้มากกว่าหนึ่ง process ในเวลาเดียวกันได้
==ฟังก์ชันกลุ่ม exec==
เป็นกลุ่มฟังก์ชันที่อยู่ใน library <unistd.h> ใช้สำหรับการ execute program การทำงานของ exec คือสร้าง process exec ขึ้นมา แล้วตรวจสอบ argument ซึ่งเป็นชื่อคำสั่งที่จะต้องการ execute ถ้าชื่อคำสั่งถูกต้องก็จะโหลดคำสั่งมาทับหน่วยความจำของคำสั่ง exec เดิม ไม่ได้มีการสร้าง process ใหม่เพิ่มเติมเหมือนคำสั่ง fork แต่อย่างใด ฟังก์ชันในกลุ่มคำสั่ง exec มีดังนี้

 * execl --- argument แรก ใช้รับค่าเป็น path name ของไฟล์ที่จะทำการ excute ส่วน ที่เหลือรับค่าของ  command line arguments และจบด้วย NULL. 
ตัวอย่าง
{{{
 execl("./a.out", NULL);
 execl("/usr/bin/vi","vi","/home/phnarong/test1.txt");
}}}
 * execv --- argument แรก ใช้รับค่าเป็น path name ของไฟล์ที่จะทำการ excute ส่วน ที่เหลือใช้ array ในการรับค่า argument ที่เหลือ
ตัวอย่าง
{{{
static char* args[] = {“ “, "cat.txt", "test1.txt", NULL}; 
execv("/bin/cp", args);
}}}
ค่า string ว่าง “ “ สามารถแทนด้วยชื่อคำสั่งของตัวมันเอง เช่น “ “ หรือปล่อยว่างไว้เช่นเดิมก็ได้ “ “.  
 * execlp --- เหมือนกับ execl แต่ไม่จำเป็นต้องรับ path name เป็น full path name ก็ได้ 
ตัวอย่าง
{{{
         execlp("ls", NULL)
}}}

==ฟังก์ชัน fork==
fork ใช้สำหรับสร้าง process ใหม่ มีรูปแบบการใช้งานดังนี้
{{{
#include<sys/types.h>
#include<unistd.h>

pid_t fork(void)
}}}

ฟังก์ชัน fork จะส่งค่ากลับเป็นค่าของ pid ของ process ลูกที่สร้างขึ้นใหม่ ถ้าส่งค่า 0 หมายถึง process ลูกเรียกคำสั่ง fork แต่ถ้า fork สร้าง process ใหม่ไม่ได้ จะส่งกลับค่า -1 ตัวอย่างการใช้ฟังก์ชัน fork มีดังนี้
{{{
  1 //fork.c
  2 // by narong
  3 #include <unistd.h>
  4 #include <stdio.h>
  5
  6 int main(void){
  7         int pid;
  8         pid =fork();
  9         if (pid==0){
 10                 printf("I am a child process\n");
 11                 printf("my getpid() is %d\n",getpid());
 12         }else if(pid<0){
 13                 perror("Cannot create process");
 14         } else{
 15                 printf("My Process ID is %d\n",pid);
 16                 printf("my getpid() is %d\n",getpid());
 17         }
 18         return 0;
 19 }
}}}
จากโค้ดด้านบน บรรทัดที่ 8 เป็นการเรียกใช้ fork แล้ว pid จะได้รับค่า pid ใหม่ของ process ลูก เมื่อ pid มีค่ามากกว่า 0 จึงไปทำงานที่บรรทัดที่ 14 หลังจาก child process ทำงานเสร็จ ก็จะตรวจสอบว่า pid เท่ากับ 0 หรือไม่ ถ้าเท่ากับ 0 ก็จะไปทำงานที่บรรทัดที่ 10-11

ตัวอย่างการทำงานกับ ด้วยฟังก์ชัน fork แสดงได้ดังโค้ดด้านล่าง
{{{
  1 //fork2.c
  2 // code by http://www.cs.cmu.edu/~guna/15-123S11/Lectures/Lecture25.pdf
  3 #include <sys/types.h>
  4 #include <unistd.h>
  5 #include <stdio.h>
  6
  7 int main(void){
  8         int A[]={1,2,3,4,5,6};
  9         int sum=0, pdt=1, PID, i;
 10         if ((PID=fork())==0){
 11                 for (i=0;i<6;i++) sum += A[i];
 12                 printf("This is child process computed sum %d \n", sum);
 13         }
 14         if (PID <0) {
 15                 perror("problem creating a process \n");
 16         }
 17         if (PID >0) {
 18                 for (i=0;i<6;i++) pdt *= A[i];
 19                 printf("The parent process completed the product %d \n", pdt);
 20         }
 21         return 0;
 22 }

}}}

==Terminating a Process==
ฟังก์ชันที่ใช้ในการหยุดการทำงาน (Terminate) process ที่กำลังทำงานอยู่ได้แก่ ฟังก์ชัน exit() โดยจะทำการ return ผลของการ terminate process ได้ 2 แบบคือ exit(EXIT_SUCCESS) ซึ่งบ่งบอกว่าออกโดยทำงานสำเร็จ หรือ exit (EXIT_FAILURE) ซึ่งบอกว่าออกโดยทำงานล้มเหลว รูปแบบการใช้งาน ฟังก์ชัน exit() มีดังนี้
{{{
#include <stdlib.h>
void exit (int status);
}}}

นอกจากนี้ process สามารถถูก Terminate ด้วย Signal ที่ใช้ในการ Terminate เช่น SIGTERM และ SIGKILL ได้อีกด้วย
==ฟังก์ชัน atexit()==
ฟังก์ชัน atexit() ใช้สำหรับเรียกฟังก์ชันที่ register ไว้ เมื่อ process ถูก Terminate ผ่านฟังก์ชัน exit() หรือ ผ่านการ return จากฟังก์ชัน main  แต่ถ้า Process ถูก Terminate ด้วย Signal ฟังก์ชันที่ register ไว้จะไม่ถูกเรียก โดยฟังก์ชัน atexit() จะ return ค่า 0 เมื่อทำงานสำเร็จ ถ้าหากล้มเหลว จะ return ค่า -1 รูปแบบของฟังก์ชัน atexit() มีดังนี้
{{{
#include <stdlib.h>
int atexit (void (*function) (void));
}}}
โดยฟังก์ชันที่่จะใช้ register ต้องไม่มีการรับค่า parameter และไม่มีการ return ค่า รูปแบบของฟังก์ชันต้นแบบจะเป็นดังนี้
{{{
void my_function (void);
}}}
ตัวอย่างการใช้งาน ฟังก์ชัน atexit() แสดงได้ดังโค้ดด้านล่าง
{{{
  1 //atexit.c
  2 // by narong ,base on Robert  Love
  3 #include <stdio.h>
  4 #include <stdlib.h>
  5
  6 void out (void)
  7 {
  8         printf ("atexit(  ) succeeded!\n");
  9 }
 10  int main (void)
 11 {
 12         printf("Now for test exiting\n");
 13         if (atexit (out)){
 14                 fprintf(stderr, "atexit(  ) failed!\n");
 15         }
 16         return 0;
 17 }

}}}
จากตัวอย่างโค้ดด้านบน ฟังก์ชัน out จะถูกประกาศไว้ตามรูปแบบต้นแบบฟังก์ชันที่จะใช้ใน atexit() ในกรณีที่โปรแกรมถูก Terminate ปกติ ฟังก์ชัน atexit() จะเรียกฟังก์ชัน out() ให้ทำงานและจะแสดงข้อความ "atexit() succeeded!" ออกหน้าจอ

==Waiting for Terminated Child Processes==
หลายครั้งที่ parent ต้องการได้รับข้อมูลอื่น ๆ จาก child ที่ถูก Terminate เช่น ค่า ที่ child return ผู้ออกแบบ UNIX จึงได้ออกแบบให้ส่ง Child ที่ถูก Terminate ก่อน parent ของมันไปอยู่ใน State พิเศษ โดยกำหนดให้ process ที่อยู่ใน state นี่ชื่อว่า "Zombie" ซึ่ง Process นี้จะยังคงเก็บจะเก็บข้อมูลโครงสร้างพื้นฐานบางอย่างของ kernel ที่มีประโยชน์ไว้อยู่ เพื่อรอให้ parent สอบถามข้อมูลเกี่ยวกับสถานะของตัวมัน หลังจากที่ parent ได้ข้อมูลจาก child ที่เป็น Zombie เรียบร้อยแล้ว zombie ก็จะถูกกำจัดทิ้ง

==ฟังก์ชัน wait()==
ระบบปฏิบัติการ Linux ได้จัดเตรียมฟังก์ชันหลายตัวสำหรับการรับข้อมูลจาก Child Process ที่ถูก Terminate ฟังก์ชันที่ใช้งานง่าย คือ wait() โดยมีรูปแบบการใช้งานดังนี้
{{{
#include <sys/types.h> 
#include <sys/wait.h> 
 
pid_t wait (int *status); 
 
}}}
ฟังก์ชัน wait จะ return ค่า PID ของ child ที่ถูก Terminate แต่หากเกิด error จะ return ค่า -1 ถ้าไม่มี child ถูก terminate เลย ฟังก์ชันจะทำการรอไปเรื่อย ๆ จนกว่าจะมี child ถูก terminate ถ้าพบว่ามี child ถูก terminate แล้ว ฟังก์ชันจะทำการ return ค่า PID ของ child นั้นทันที ค่า error ที่อาจเกิดขึ้นได้มี 2 ค่าได้แก่
||ECHILD || The calling process does not have any children. ||
||EINTR || A signal was received while waiting, and the call returned early.  ||

ถ้าค่าที่ return ไม่ใช่ null ข้อมูลเพิ่มเติมอื่น ๆ ของ child จะสามารถหาได้จากตัวแปร pointer status ที่ทำงานในมาโครฟังก์ชันของภาษา C เตรียมไว้สำหรับแปลข้อมูลต่าง ๆ ของ child โดยมีรูปแบบการใช้งาน ดังนี้
{{{
#include <sys/wait.h> 
 
int WIFEXITED (status); 
int WIFSIGNALED (status); 
int WIFSTOPPED (status); 
int WIFCONTINUED (status); 
 
int WEXITSTATUS (status); 
int WTERMSIG (status); 
int WSTOPSIG (status); 
int WCOREDUMP (status); 
 
}}}
รายละเอียดความหมายต่าง ๆ ของ macro function แสดงได้ดังนี้
||WIFEXITED|| จะ return true ถ้า child process ได้ถูก terminated แบบปกติ||
||WEXITSTATUS|| จะเตรียมข้อมูล 8 bit ที่ผ่านจากฟังก์ชัน {{{_exit()}}} สำหรับกรณี ที่ WIFEXITED return ค่า true||
||WIFSIGNALED|| จะ return ค่า true ถ้า child process ถูก terminate เพราะ Signal ||
||WTERMSIG|| จะ return ค่าของ Signal ที่เป็นสาเหตุที่ทำให้ child ถูก terminate สำหรับกรณีที่ WIFSIGNALED return ค่า true||
||WCOREDUMP|| จะ return ค่า true หาก child process ถูก terminate และมีการผลิต core dump||
||WIFSTOPPED|| จะ return ค่า true หาก child process ถูกหยุดการทำงาน||
||WSTOPSIG|| จะ return ค่าของ Signal ที่เป็นสาเหตุที่ทำให้ child หยุดการทำงาน สำหรับกรณีที่ WIFSTOPPED return ค่า true||


==User and Group==

==Daemons==

=References=
  # Wiil-Hans Steeb, et al, _Linux, Shell Programming and Perl_ [http://issc.uj.ac.za/downloads/linux.pdf  PDF]
  # Ananda Gunawardena, _Process Control_ [http://www.cs.cmu.edu/~guna/15-123S11/Lectures/Lecture25.pdf PDF]
  # March H. Scholl, _Process Control Subsystem_ [http://www.inf.uni-konstanz.de/dbis/teaching/ss09/os/L2.pdf PDF]
 # www.no-poor.com, _Process and Threads_ [http://www.no-poor.com/dssandos/os_ch03_process.htm HTML]
 # lecture.cs.buu.ac.th, _s49232 Lab06 fork_ [https://docs.google.com/viewer?url=http%3A%2F%2Flecture.cs.buu.ac.th%2F~s49232%2FLab06%2Ffork.doc DOC]
----
[CourseSchedule2555_2 กลับไปหน้าหลัก]-->[<a href="https://code.google.com/p/system-programming-cs3402-at-crma/wiki/CourseSchedule2555_2#ตารางเรียน_๒๕๕๕/๒">ตารางเรียน</a>]-->Next: [cSysProg C กับ System Programming]

[https://code.google.com/p/system-programming-cs3402-at-crma/w/edit/CShell Edit]