#summary การประยุกต์ใช้เชลล์สคริปต์ ๓
[CourseSchedule2555_2 กลับไปหน้าหลัก]-->[<a href="https://code.google.com/p/system-programming-cs3402-at-crma/wiki/CourseSchedule2555_2#ตารางเรียน_๒๕๕๕/๒">ตารางเรียน</a>]-->Next: [midtermReview ทบทวนก่อนสอบระหว่างภาค]
<table width=500>
<td>
<wiki:toc max_depth="3" />
=Base Numbers=
ตัวอย่างต่อไปนี้ไฟล์ [https://code.google.com/p/system-programming-cs3402-at-crma/source/browse/trunk/shell/advanced/basenum.sh basenum.sh] แสดงให้เห็นการประยุกต์ใช้คำสั่ง printf ซึ่งสามารถควบคุมรูปแบบของผลลัพธ์ที่เกี่ยวข้องกับเลขฐานสิบหก สิบ และแปดได้ ส่วนเลขฐานสองนั้นเราประยุกต์ใช้การติดต่อกับโปรแกรม bc แทน
{{{
     1  #!/bin/bash
     2  #written by pyavinci@gmail.com (P. Chalermwat)
     3  let i=1
     4    printf "DEC\t OCT\t HEX\t BIN\n"
     5  while [ $i -le "20" ]; do
     6    b=$(echo "obase=2; ibase=10; $i" | bc)
     7    printf "%d\t %o\t %X\t %s\n" $i $i $i $b
     8    let i++
     9  done
}}}
เมื่อรันโปรแกรมด้วยคำสั่ง
{{{
prachya@pcubusrv104> ./basenum.sh
}}}
จะได้ผลลัพธ์ดังนี้
{{{
DEC      OCT     HEX     BIN
1        1       1       1
2        2       2       10
3        3       3       11
4        4       4       100
5        5       5       101
6        6       6       110
7        7       7       111
8        10      8       1000
9        11      9       1001
10       12      A       1010
11       13      B       1011
12       14      C       1100
13       15      D       1101
14       16      E       1110
15       17      F       1111
16       20      10      10000
17       21      11      10001
18       22      12      10010
19       23      13      10011
20       24      14      10100
}}}


อย่างไรก็ตามคำสั่ง printf ไม่สามารถแปลงเลข hex ให้กลับมาเป็นเลขฐาน 10 หรือฐาน 2 ได้ เราต้องการใช้ฟอร์แม็ตแบบพิเศษคือ {{{$((16#$i))}}} ในบรรทัดที่ 14 เพื่อแปลงเลขฐาน 16 ให้กลับมาเป็นฐาน 10 ดังแสดงตัวอย่างในไฟล์ 
[https://code.google.com/p/system-programming-cs3402-at-crma/source/browse/trunk/shell/advanced/basenum2.sh basenum2.sh] ต่อไปนี้

{{{
     1  #!/bin/bash
     2  #written by pyavinci@gmail.com (P. Chalermwat)
     3  let i=1
     4  #create input hex sequence
     5  h=$(while [ $i -le "20" ]; do
     6    printf "%X " $i
     7    let i++
     8    done)
     9  echo INPUT=$h
    10  echo "Converting to decimal..."
    11  printf "HEX\t DEC\t BIN\n"
    12  for i in $h; do
    13    b=$(echo "obase=2; ibase=16; $i" | bc)
    14    printf "%s\t %s\t %s\n" $i $((16#$i)) $b
    15  done
}}}

เมื่อรันคำสั่งต่อไปนี้
{{{
prachya@pcubusrv104> ./basenum2.sh
}}}
จะได้ผลลัพธ์ตามนี้
{{{
INPUT=1 2 3 4 5 6 7 8 9 A B C D E F 10 11 12 13 14
Converting to decimal...
HEX      DEC     BIN
1        1       1
2        2       10
3        3       11
4        4       100
5        5       101
6        6       110
7        7       111
8        8       1000
9        9       1001
A        10      1010
B        11      1011
C        12      1100
D        13      1101
E        14      1110
F        15      1111
10       16      10000
11       17      10001
12       18      10010
13       19      10011
14       20      10100
}}}
=Trap Command=
คำสั่ง trap ใช้สำหรับกำหนดการกระทำคำสั่งใด ๆ เมื่อได้รับสัญญาณ (signal) การใช้งานทั่วไปจะใช้ในการให้สคริปต์ทำงานเมื่อได้รับการ [interruptExplain interrupt] จากสัญญาณใด รูปแบบของคำสั่ง trap คือ
{{{
trap command signal
}}}
สัญญาณ (signal) ที่เป็นที่ทราบ/ใช้กันมาก
||Signal(หมายเลข )|| คำอธิบาย||
||HUP (1) ||Hang up; ใช้ส่งไปให้ terminal นั้นเป็น offline หรือผู้ใช้ล็อกเอาท์ออกจากระบบ||
||INT (2) ||Interrupt; ส่งด้วยการกดคีย์ {{{<Ctrl-C>}}}||
||QUIT(3) ||Quit; ส่งสัญญาณด้วยการกดคีย์ {{{<Ctrl-\>}}}||
||ABRT(6) ||Abort; ส่งเมื่อการปัญหาในการรันโปรแกรม||
||ALRM(14)|| Alarm; ส่งเพื่อสื่อสารเกี่ยวกับการแจ้งเตือนการหมดเวลา (time-outs)||
||TERM(15)|| Terminate; ส่งเมื่อระบบจะหยุดการทำงาน (shutting down)||

==ตัวอย่าง==
ไฟล์ซอร์สโค้ดสามารถดูได้ที่ [https://code.google.com/p/system-programming-cs3402-at-crma/source/browse/trunk/shell/advanced/trap.sh trap.sh]
{{{
     1  #! /bin/bash
     2  # from Steeb WH, Linux, Shell Programming and Perl
     3  trap 'rm -f /tmp/my_tmp_file_$$' INT
     4  echo creating file /tmp/my_tmp_file_$$
     5  date > /tmp/my_tmp_file_$$
     6  echo "press interrupt (CRTL-C) to interrupt ... "
     7  while [ -f /tmp/my_tmp_file_$$ ]; do
     8    echo File exists
     9    sleep 1
    10  done
    11  echo The file no longer exists
    12  trap - INT
    13  echo creating file /tmp/my_tmp_file_$$
    14  date > /tmp/my_tmp_file_$$
    15  echo "press interrupt (CRTL-C) to interrupt ... "
    16  while [ -f /tmp/my_tmp_file_$$ ]; do
    17    echo File exists
    18    sleep 1
    19  done
    20  echo We never get here
    21  exit 0
}}}

รันเชลล์นี้ด้วยคำสั่ง
{{{
prachya@pcubusrv104> ./trap.sh
}}}
จะได้ผลลัพธ์ดังนี้ ให้กด Ctrl-C เพื่อส่งสัญญาณ INT (2) ไปยังเชลล์เมื่อเชลล์ได้รับสัญญาณ ก็จะทำคำสั่งที่กำหนดไว้ใน trap ในบรรทัดที่ 3 คือ {{{rm -f /tmp/my_tmp_file_$$}}}
{{{
creating file /tmp/my_tmp_file_16658
press interrupt (CRTL-C) to interrupt ...
File exists
File exists
File exists
^CThe file no longer exists
creating file /tmp/my_tmp_file_16658
press interrupt (CRTL-C) to interrupt ...
File exists
File exists
File exists
File exists
File exists
^C
}}}

=Google Search=

ไฟล์ต้นฉบับสามารถดูได้ที่ [https://code.google.com/p/system-programming-cs3402-at-crma/source/browse/trunk/shell/advanced/google.sh google.sh]
{{{
     1  #!/bin/bash
     2  # http://stackoverflow.com/questions/5506561/getting-the-urls-for-the-first-google-search-results-in-a-shell-script
     3  clear
     4  echo ""
     5  echo ".=========================================================."
     6  echo "|                                                         |"
     7  echo "|  COMMAND LINE GOOGLE SEARCH                             |"
     8  echo "|  ---------------------------------------------------    |"
     9  echo "|                                                         |"
    10  echo "|  Version: 1.0                                           |"
    11  echo "|  Developed by: Rishi Narang                             |"
    12  echo "|  Blog: www.wtfuzz.com                                   |"
    13  echo "|                                                         |"
    14  echo "|  Usage: ./gocmd.sh <search strings>                     |"
    15  echo "|  Example: ./gocmd.sh example and test                   |"
    16  echo "|                                                         |"
    17  echo ".=========================================================."
    18  echo ""
    19
    20  if [ -z $1 ]
    21  then
    22   echo "ERROR: No search string supplied."
    23   echo "USAGE: ./gocmd.sh <search srting>"
    24   echo ""
    25   echo -n "Anyways for now, supply the search string here: "
    26   read SEARCH
    27  else
    28   SEARCH=$@
    29  fi
    30
    31  URL="http://google.com/search?hl=en&safe=off&q="
    32  STRING=`echo $SEARCH | sed 's/ /%20/g'`
    33  URI="$URL%22$STRING%22"
    34
    35  lynx -dump $URI > gone.tmp
    36  sed 's/http/\^http/g' gone.tmp | tr -s "^" "\n" | grep http| sed 's/\ .*//g' > gtwo.tmp
    37  rm gone.tmp
    38  sed '/google.com/d' gtwo.tmp > urls
    39  rm gtwo.tmp
    40
    41  echo "SUCCESS: Extracted `wc -l urls` and listed them in '`pwd`/urls' file for reference."
    42  echo ""
    43  cat urls
    44  echo "
}}}

=shar.sh=

ไฟล์ [https://code.google.com/p/system-programming-cs3402-at-crma/source/browse/trunk/shell/advanced/shar.sh  shar.sh]
{{{
#!/bin/sh
tar xvfz << "EOF"
}}}

{{{
> tar cfz newar.tar.gz some_directory
> cat shar.sh newar.tgz > newar.shar
> echo "EOF" >> newar.shar
> chmod +x newar.shar
}}}

ไฟล์ [https://code.google.com/p/system-programming-cs3402-at-crma/source/browse/trunk/shell/advanced/shar2.sh shar2.sh]
{{{
     1  #!/bin/sh
     2  #Assume $1=n processes $2=host $3=user $4=password $5=filename
     3  # From WH Steeb, Linux, Shell Programming and Perl, p.178
     4  n="$1"
     5  host="$2"
     6  ftpuser="$3"
     7  ftppass="$4"
     8  filename="$5"
     9  file=$(basename "$filename")
    10  #obtain the filesize
    11  name=$(\
    12  {
    13    echo user "$ftpuser" \'"$ftppass"\'
    14    echo bin
    15    echo size "$filename"
    16    echo quit
    17    } | ftp -n "\$host" | \
    18    {
    19    while [ "$name" != "$filename" ]
    20    do
    21      read name filesize
    22      echo -n $name $filesize
    23    done
    24  })
    25
    26  set --set $name
    27  filesize=$2
    28  chunksize=$(($n-1))
    29  chunksize=$(($filesize/$chunksize))
    30  if [ "$chunksize" -eq 0 ]
    31  then
    32  chunksize=$filesize
    33  n=1
    34  fi
    35  i=0
    36  set --#start the ftp processes
    37  while [ $i -lt $n ]
    38  do
    39    if [ ! -e \$\{file\}.\$i ]
    40    then
    41    dd if=/dev/zero of=${file}.$i bs=$chunksize count=$i \
    42    > /dev/null 2> /dev/null
    43    fi
    44    rm -f $file 2> /dev/null
    45    {
    46      echo user "$ftpuser" \'"$ftppass"\'
    47      echo bin
    48      echo reget $filename ${file}.$i
    49      echo quit
    50    } | ftp -nv \$host > /dev/null &
    51    # a list of process ids for the ftp processes
    52    set $* $!
    53    i=$(($i+1))
    54  done
    55
    56  i=0
    57  for j in $*
    58  do
    59    csize=0
    60    k=$(($i+1))
    61    k=$(($k*$chunksize))
    62    while [ "$csize" -le "$k" ] \&\& [ "$csize" -lt $filesize ]
    63    do
    64      set -- $(ls -l ${file}.$i)
    65      csize=$5
    66      printf "$csize / $filesize of $file \r"
    67      sleep 1
    68    done
    69    kill $j > /dev/null 2> /dev/null
    70    dd if=${file}.$i bs=$chunksize skip=$i count=1 >> $file 2> /dev/null
    71    rmfiles="$rmfiles ${file}.$i"
    72    i=$(($i+1))
    73  done
    74  echo
    75  #only do this at the end so that an interrupted
    76  # download can continue
    77  rm $rmfiles
}}}

=GCD: Greatest Common Divisor=
การหาตัวหารร่วมมาก (ห.ร.ม.) หรือ GCD สามารถคำนวณได้ด้วยการใช้เชลล์สคริปต์ตามตัวอย่างในไฟล์ [https://code.google.com/p/system-programming-cs3402-at-crma/source/browse/trunk/shell/advanced/gcd.sh gcd.sh] ด้านล่าง
{{{
#!/bin/bash
# gcd.sh: greatest common divisor
#         Uses Euclid's algorithm

#  The "greatest common divisor" (gcd) of two integers
#+ is the largest integer that will divide both, leaving no remainder.

#  Euclid's algorithm uses successive division.
#    In each pass,
#+      dividend <---  divisor
#+      divisor  <---  remainder
#+   until remainder = 0.
#    The gcd = dividend, on the final pass.
#
#  For an excellent discussion of Euclid's algorithm, see
#+ Jim Loy's site, http://www.jimloy.com/number/euclids.htm.


# ------------------------------------------------------
# Argument check
ARGS=2
E_BADARGS=85

if [ $# -ne "$ARGS" ]
then
  echo "Usage: `basename $0` first-number second-number"
  exit $E_BADARGS
fi
# ------------------------------------------------------
}}}
=References=
  * Mendel Cooper, _Advanced Bash-Scripting Guide: An in-depth exploration of the art of shell scripting_, http://tldp.org/LDP/abs/html/
  * Machtelt Garrels, _Bash Guide for Beginners_ , http://tldp.org/LDP/Bash-Beginners-Guide/html/index.html